# Tech Guardrails - Battle-Tested Patterns

**Issus de sessions de debugging r√©elles. Ces patterns ont caus√© des bugs en production. Ne pas ignorer.**

---

## üêç Python / FastAPI

### Garde-Fou 1: Type Hints (Python 3.12)

**Probl√®me**: `PydanticUserError: 'List' is not a valid type hint`

**Cause**: Python 3.9+ supporte `list[]` natif, mais `List` de `typing` cr√©e des conflits avec Pydantic v2.

```python
# ‚ùå DANGER
from typing import List, Dict, Optional

class UserResponse(BaseModel):
    interests: List[str]  # PydanticUserError en Python 3.12+
    metadata: Dict[str, str]
    bio: Optional[str]

# ‚úÖ CORRECT
from typing import Optional  # OK pour Optional

class UserResponse(BaseModel):
    interests: list[str]  # Utilise list[] natif Python 3.9+
    metadata: dict[str, str]
    bio: str | None  # Ou utilise union type Python 3.10+
```

**R√®gle**: **Utilise imp√©rativement `list[]`, `dict[]`, `set[]`, `tuple[]`** (Python 3.9+ builtins). Seul `Optional[]` de `typing` est OK si tu pr√©f√®res √† `| None`.

**Fichiers concern√©s**:
- Tous schemas: `packages/api/app/schemas/*.py`
- Tous models: `packages/api/app/models/*.py`
- Type hints partout

**V√©rification**:
```bash
cd packages/api && source venv/bin/activate
python -c "from app.schemas.user import UserResponse; print('OK')"
# Si erreur ‚Üí cherche List/Dict/Set dans les imports
```

---

### Garde-Fou 2: Async/Await Partout

**Probl√®me**: Blocking I/O dans async context ‚Üí performance d√©grad√©e, timeouts.

**Cause**: M√©lange sync/async code dans FastAPI/SQLAlchemy.

```python
# ‚ùå DANGER
@router.get("/users/{user_id}")
def get_user(user_id: UUID, db: Session):  # Session sync
    user = db.query(User).filter(User.id == user_id).first()
    return user

# ‚úÖ CORRECT
@router.get("/users/{user_id}")
async def get_user(
    user_id: UUID,
    db: AsyncSession = Depends(get_db)  # AsyncSession
):
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    user = result.scalar_one_or_none()
    return user
```

**R√®gle**: **Tout I/O doit √™tre async** (DB, HTTP, file I/O).

**Exceptions**:
- CPU-bound tasks: Use `run_in_executor()` pour offload √† thread pool
  ```python
  loop = asyncio.get_event_loop()
  result = await loop.run_in_executor(None, cpu_intensive_function, args)
  ```

**V√©rification**:
```bash
# Recherche appels sync dans code async
cd packages/api
rg "def (get_|post_|put_|delete_)" app/routers/  # Doit trouver "async def"
```

---

### Garde-Fou 3: Structlog Partout (Pas de `print()`)

**Probl√®me**: `print()` en production ‚Üí logs non-structur√©s, difficiles √† filtrer/analyser dans Sentry.

**Cause**: Debug rapide avec `print()`, jamais nettoy√©.

```python
# ‚ùå DANGER
def sync_feed(source_id: int):
    print(f"Syncing source {source_id}")  # Non-structur√©
    # ...
    print(f"Synced {len(articles)} articles")

# ‚úÖ CORRECT
import structlog

logger = structlog.get_logger(__name__)

async def sync_feed(source_id: int):
    logger.info("sync_started", source_id=source_id)
    # ...
    logger.info("sync_completed", source_id=source_id, article_count=len(articles))
```

**R√®gle**: **Jamais `print()` en code production.** Utilise `structlog` avec key-value pairs.

**Fichiers avec `print()` restants** (tech debt):
- `packages/api/app/routers/feed.py`
- `packages/api/app/dependencies.py`

**TODO**: Remplacer par structlog.

**V√©rification**:
```bash
cd packages/api
rg "print\(" app/  # Doit retourner 0 (ou seulement tech debt connu)
```

---

## üîê Supabase Auth

### Garde-Fou 4: Stale Token (Email Confirmation)

**Probl√®me**: JWT token contient `email_confirmed_at=null` m√™me apr√®s confirmation ‚Üí user bloqu√© sur √©cran confirmation.

**Cause**: Token g√©n√©r√© AVANT confirmation email, jamais rafra√Æchi.

```python
# ‚ùå DANGER: Ne fais JAMAIS confiance au JWT seul
from jose import jwt

def is_email_confirmed(token: str) -> bool:
    payload = jwt.decode(token, SECRET, algorithms=["RS256"])
    return payload.get("email_confirmed_at") is not None
    # Bug: payload peut √™tre stale (g√©n√©r√© avant confirmation)

# ‚úÖ CORRECT: Query Supabase auth.users en temps r√©el
from supabase import Client

async def is_email_confirmed(user_id: UUID, supabase: Client) -> bool:
    response = supabase.auth.admin.get_user_by_id(str(user_id))
    return response.user.email_confirmed_at is not None
```

**R√®gle**: **Pour comptes email, toujours v√©rifier `auth.users` c√¥t√© serveur.** Ne jamais faire confiance au JWT seul pour `email_confirmed_at`.

**Alternative mobile**: Forcer refresh session apr√®s confirmation.

```dart
// ‚úÖ CORRECT (mobile)
Future<void> confirmEmail(String token) async {
  await supabase.auth.verifyOTP(token: token, type: OtpType.email);

  // Force refresh session pour obtenir JWT √† jour
  await supabase.auth.refreshSession();

  // Maintenant authStateProvider.isEmailConfirmed sera correct
}
```

**Fichiers concern√©s**:
- `packages/api/app/dependencies.py` (JWT validation)
- `apps/mobile/lib/core/auth/auth_state.dart`

**V√©rification**:
```bash
# Test: User confirme email ‚Üí doit √™tre redirected to home (pas bloqu√©)
# Manual test requis (Flutter simulator)
```

---

### Garde-Fou 5: JWT Secret Mismatch

**Probl√®me**: Mobile et Backend utilisent des `SUPABASE_JWT_SECRET` diff√©rents ‚Üí 403 sur tous endpoints.

**Cause**: Env vars mal configur√©es, copi√©/coll√© entre projets.

```bash
# ‚ùå DANGER: Secrets diff√©rents
# Mobile .env
SUPABASE_JWT_SECRET=secret_from_project_A

# Backend .env
SUPABASE_JWT_SECRET=secret_from_project_B

# R√©sultat: JWT sign√© avec secret_A, valid√© avec secret_B ‚Üí FAIL

# ‚úÖ CORRECT: M√™me secret partout
# Supabase Dashboard ‚Üí Settings ‚Üí API ‚Üí JWT Secret
# Copie EXACTEMENT le m√™me dans mobile ET backend
```

**R√®gle**: **V√©rifie coh√©rence `SUPABASE_JWT_SECRET`** entre mobile et backend.

**V√©rification**:
```bash
# Backend
cd packages/api && source venv/bin/activate
python -c "from app.config import settings; print(settings.SUPABASE_JWT_SECRET[:10])"

# Mobile (check build args)
cd apps/mobile
flutter run --dart-define=SUPABASE_JWT_SECRET=$SUPABASE_JWT_SECRET
# V√©rifie que $SUPABASE_JWT_SECRET matche backend
```

---

## üóÑÔ∏è Database / SQLAlchemy

### Garde-Fou 6: Foreign Key Confusion

**Probl√®me**: Confusion entre `user_profiles.id` (PK) et `user_profiles.user_id` (FK vers `auth.users`) ‚Üí mauvais joins, data mix√©e.

**Cause**: Inconsistency dans le mod√®le de donn√©es.

```python
# ‚ùå DANGER: Quelle FK utiliser?
class DailyDigest(Base):
    user_id: Mapped[UUID]  # FK vers auth.users.id ou user_profiles.id?

# R√©ponse d√©pend du mod√®le:
# - Certaines tables FK vers auth.users.id directement
# - D'autres FK vers user_profiles.id

# ‚úÖ CORRECT: TOUJOURS v√©rifier le sch√©ma
# Utilise DBeaver ou psql pour voir les contraintes FK

# Exemple: daily_digest
SELECT
    conname AS constraint_name,
    conrelid::regclass AS table_name,
    a.attname AS column_name,
    confrelid::regclass AS referenced_table
FROM pg_constraint c
JOIN pg_attribute a ON a.attnum = ANY(c.conkey) AND a.attrelid = c.conrelid
WHERE contype = 'f' AND conrelid::regclass::text = 'daily_digest';

# Si r√©f√©rence auth.users ‚Üí utilise user_id directement
# Si r√©f√©rence user_profiles ‚Üí utilise profile_id
```

**R√®gle**: **Avant tout join, v√©rifie quelle FK utilise la table** (`auth.users.id` ou `user_profiles.id`).

**Fichiers √† risque**:
- `packages/api/app/models/daily_digest.py`
- `packages/api/app/models/user_content_status.py`
- `packages/api/app/models/user_personalization.py`

**V√©rification**:
```sql
-- Dans psql ou DBeaver
\d+ daily_digest  -- Voir FK constraints
```

---

### Garde-Fou 7: Migration Lock Timeout (Supabase PgBouncer)

**Probl√®me**: Migration timeout sur grosse table ‚Üí deploy fail, rollback manuel.

**Cause**: Supabase pooler en mode "transaction", migrations Alembic lock tables, timeout apr√®s 60s.

```python
# ‚ùå DANGER: ALTER TABLE sur grosse table
def upgrade():
    op.add_column('contents', sa.Column('new_field', sa.String))
    # contents table a 50k+ rows ‚Üí lock timeout

# ‚úÖ CORRECT: Migration avec lock timeout handling
def upgrade():
    from alembic import op
    from sqlalchemy import text

    connection = op.get_bind()

    # Set lock timeout
    connection.execute(text("SET lock_timeout = '10s'"))

    # Si grosse table, ajoute colonne nullable PUIS peuple en batches
    op.add_column('contents', sa.Column('new_field', sa.String, nullable=True))

    # Peuplement en batches (pas dans migration, mais dans script s√©par√©)
    # Ou utilise background task
```

**R√®gle**: **Pour migrations sur tables volumineuses** (`contents`, `user_content_status`), utilise:
1. Lock timeout handling
2. Colonnes nullable si possible
3. Batches pour data migration

**Fichiers concern√©s**:
- `packages/api/alembic/versions/*.py`

**V√©rification**:
```bash
# Test migration sur copie DB prod
DATABASE_URL=postgresql://test alembic upgrade head
# Si timeout ‚Üí refactor migration
```

---

## üì± Mobile / Flutter

### Garde-Fou 8: API Client Timeout Workaround

**Probl√®me**: Mobile timeout sur API calls imm√©diatement apr√®s login ‚Üí 100ms delay workaround.

**Cause**: Supabase auth state pas ready quand API calls fire.

```dart
// ‚ùå DANGER: Supprimer le delay sans fix du root cause
Future<void> login() async {
  await supabase.auth.signInWithPassword(email: email, password: password);
  // Appel API imm√©diat ‚Üí token pas encore propag√© dans Dio interceptor
  final digest = await digestRepository.fetchTodayDigest(); // FAIL
}

// ‚úÖ CORRECT: Keep workaround jusqu'√† fix state machine
Future<void> login() async {
  await supabase.auth.signInWithPassword(email: email, password: password);

  // Workaround: attendre 100ms pour propagation auth state
  await Future.delayed(Duration(milliseconds: 100));

  // Maintenant OK
  final digest = await digestRepository.fetchTodayDigest();
}
```

**R√®gle**: **Keep le 100ms delay workaround** jusqu'√† refactor complet de `auth_state.dart` avec state machine propre.

**Fichiers concern√©s**:
- `apps/mobile/lib/core/auth/auth_state.dart`
- `apps/mobile/lib/features/auth/screens/login_screen.dart`

**TODO**: Refactor auth state machine pour √©liminer race condition.

---

### Garde-Fou 9: Build Runner Apr√®s Freezed/Riverpod

**Probl√®me**: Freezed/Riverpod code generation pas run ‚Üí compile errors.

**Cause**: Oubli de `build_runner` apr√®s modif models.

```bash
# ‚ùå DANGER: Modifier model sans build_runner
# apps/mobile/lib/models/digest.dart modifi√©
# ‚Üí compile error: "DigestModel.fromJson not found"

# ‚úÖ CORRECT: TOUJOURS run build_runner apr√®s modif
cd apps/mobile
dart run build_runner build --delete-conflicting-outputs
```

**R√®gle**: **Apr√®s TOUTE modif Freezed/Riverpod**, run `build_runner`.

**Fichiers concern√©s**:
- Tous `*.freezed.dart` (models)
- Tous `*.g.dart` (providers)

**V√©rification**:
```bash
cd apps/mobile
flutter analyze  # Doit retourner 0 errors
```

---

## üß™ Testing / QA

### Garde-Fou 10: Self-Sufficient Verification Scripts

**Probl√®me**: Script de v√©rification assume venv activ√©, cwd correct ‚Üí fail quand run manuellement.

**Cause**: Scripts √©crits pour usage agent, pas user.

```bash
# ‚ùå DANGER: Script d√©pend de l'environnement
#!/bin/bash
pytest tests/test_digest.py  # Assume venv activ√©, cwd = packages/api

# ‚úÖ CORRECT: Script self-sufficient
#!/bin/bash
set -e

# Navigate to script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"

# Navigate to API directory
cd "$PROJECT_ROOT/packages/api"

# Activate venv
if [ ! -d "venv" ]; then
  echo "‚ùå Virtual environment not found. Run: python3 -m venv venv && pip install -r requirements.txt"
  exit 1
fi

source venv/bin/activate

# Run tests
pytest tests/test_digest.py

echo "‚úÖ Digest tests passed"
```

**R√®gle**: **Tous scripts dans `docs/qa/scripts/`** doivent √™tre self-sufficient:
1. Gestion du `cd` (chemins absolus)
2. Activation venv si n√©cessaire
3. V√©rification des d√©pendances
4. Messages d'erreur clairs

**V√©rification**:
```bash
# Test: Run script depuis n'importe o√π
cd /tmp
/Users/laurinboujon/Desktop/Projects/Work\ Projects/Facteur/docs/qa/scripts/verify_digest.sh
# Doit fonctionner sans erreur
```

---

## üöÄ Deployment / Railway

### Garde-Fou 11: Health Check vs Readiness

**Probl√®me**: Health check simple `/api/health` retourne 200 m√™me si DB down ‚Üí Railway pense app healthy, route trafic.

**Cause**: Liveness vs Readiness distinction pas claire.

```python
# ‚ùå DANGER: Health check qui ne v√©rifie rien
@router.get("/health")
async def health():
    return {"status": "ok"}  # Toujours 200, m√™me si DB down

# ‚úÖ CORRECT: Deux endpoints
@router.get("/health")
async def liveness():
    """Liveness probe: App running?"""
    return {"status": "ok"}

@router.get("/health/ready")
async def readiness(db: AsyncSession = Depends(get_db)):
    """Readiness probe: App ready to serve traffic?"""
    try:
        # Check DB connectivity
        await db.execute(text("SELECT 1"))
        return {"status": "ready", "database": "connected"}
    except Exception as e:
        raise HTTPException(status_code=503, detail="Database unavailable")
```

**R√®gle**: **Utilise `/health/ready` pour Railway health checks** (v√©rifie DB).

**Configuration Railway**:
```json
{
  "healthcheck": {
    "path": "/api/health/ready",
    "interval": 30,
    "timeout": 10
  }
}
```

---

## üìã Quick Guardrails Checklist

**Avant commit**:

- [ ] **Python type hints**: `list[]` pas `List[]`
- [ ] **Async partout**: Tous I/O avec `async`/`await`
- [ ] **Structlog**: Pas de `print()` restant
- [ ] **Auth secrets**: `SUPABASE_JWT_SECRET` coh√©rent mobile ‚Üî backend
- [ ] **Freezed/Riverpod**: `build_runner` run apr√®s modif models
- [ ] **Migrations**: Lock timeout handling si grosse table
- [ ] **Scripts QA**: Self-sufficient (chemins absolus, venv handling)

---

*Derni√®re MAJ: 2026-02-14*
*Sources: Retrospectives, handoffs, maintenance docs*
