# Story 10.5 : Endpoint GET /api/digest

## Status: Draft

## Story

**As a** application mobile,  
**I want** récupérer le digest quotidien de l'utilisateur via une API,  
**so that** l'écran Digest puisse afficher les 5 articles du jour.

## Acceptance Criteria

1. **Endpoint `GET /api/digest`** retourne le digest du jour
2. **Génération lazy** : Si pas de digest pour aujourd'hui, le générer à la volée
3. **Structure de réponse** avec :
   - `digest_date` (date du jour)
   - `items[]` (5 articles avec détails complets)
   - `progress` (ex: "2/5")
   - `is_complete` (boolean)
   - `estimated_reading_time` (somme des durées)
4. **Inclusion des détails Content** pour chaque item (pas juste les IDs)
5. **Authentification requise** (JWT Supabase)

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Créer le router `digest_router.py`**
  - [ ] Fichier `packages/api/app/routers/digest_router.py`
  - [ ] Route `GET /api/digest`
  - [ ] Dépendance `get_current_user`

- [ ] **Task 2: Créer le service `DigestService`**
  - [ ] Fichier `packages/api/app/services/digest_service.py`
  - [ ] Méthode `get_or_create_today_digest(user_id) -> DailyDigest`
  - [ ] Méthode `enrich_digest_with_content(digest) -> DigestResponse`

- [ ] **Task 3: Implémenter la génération lazy**
  - [ ] Vérifier si `daily_digest` existe pour `(user_id, today)`
  - [ ] Si non → appeler `DigestSelector.select_digest()`
  - [ ] Persister le nouveau digest
  - [ ] Retourner le digest

- [ ] **Task 4: Créer les schémas de réponse**
  - [ ] `DigestItemResponse` : content enrichi + status + rank
  - [ ] `DigestResponse` : date, items, progress, is_complete, reading_time
  - [ ] `ContentSummary` : id, title, url, thumbnail, source, duration, type

- [ ] **Task 5: Enregistrer le router**
  - [ ] Ajouter dans `main.py` : `app.include_router(digest_router)`

## Dev Notes

### Spécification API

```yaml
GET /api/digest
Authorization: Bearer <jwt>

Response 200:
{
  "digest_date": "2026-01-31",
  "generated_at": "2026-01-31T08:00:00Z",
  "progress": "2/5",
  "is_complete": false,
  "estimated_reading_time_minutes": 12,
  "has_curated_fallback": false,
  "items": [
    {
      "rank": 1,
      "status": "read",
      "digest_reason": "À la Une",
      "actioned_at": "2026-01-31T08:15:00Z",
      "content": {
        "id": "uuid-1",
        "title": "GPT-5 lancé par OpenAI",
        "url": "https://...",
        "thumbnail_url": "https://...",
        "description": "...",
        "published_at": "2026-01-31T06:00:00Z",
        "duration_seconds": 180,
        "content_type": "article",
        "source": {
          "id": "uuid-source",
          "name": "TechCrunch",
          "logo_url": "https://...",
          "theme": "tech"
        }
      }
    },
    // ... 4 autres items
  ]
}

Response 401:
{
  "detail": "Not authenticated"
}
```

### Implémentation Router

```python
# packages/api/app/routers/digest_router.py

from datetime import date
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.auth import get_current_user
from app.core.database import get_session
from app.schemas.digest import DigestResponse
from app.services.digest_service import DigestService

router = APIRouter(prefix="/api/digest", tags=["digest"])


@router.get("", response_model=DigestResponse)
async def get_today_digest(
    user_id: str = Depends(get_current_user),
    session: AsyncSession = Depends(get_session),
):
    """
    Récupère le digest quotidien de l'utilisateur.
    
    Génère automatiquement le digest si non existant pour aujourd'hui.
    """
    service = DigestService(session)
    
    try:
        digest = await service.get_or_create_today_digest(user_id)
        return await service.enrich_digest_with_content(digest)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### Implémentation Service

```python
# packages/api/app/services/digest_service.py

from datetime import date, datetime
from typing import Optional
from uuid import UUID

import structlog
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.models import DailyDigest, Content, Source
from app.schemas.digest import DigestResponse, DigestItemResponse, ContentSummary
from app.services.digest_selector import DigestSelector

logger = structlog.get_logger()


class DigestService:
    """Service pour gérer les digests quotidiens."""
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_or_create_today_digest(self, user_id: UUID) -> DailyDigest:
        """
        Récupère le digest du jour ou le crée si inexistant.
        """
        today = date.today()
        
        # Check if digest exists
        result = await self.session.execute(
            select(DailyDigest).where(
                DailyDigest.user_id == user_id,
                DailyDigest.digest_date == today
            )
        )
        digest = result.scalar_one_or_none()
        
        if digest:
            logger.info("Digest found", user_id=str(user_id), date=str(today))
            return digest
        
        # Generate new digest
        logger.info("Generating new digest", user_id=str(user_id), date=str(today))
        
        selector = DigestSelector(self.session)
        items = await selector.select_digest(user_id)
        
        digest = DailyDigest(
            user_id=user_id,
            digest_date=today,
            items=[item.dict() for item in items],
            total_items=len(items),
        )
        
        self.session.add(digest)
        await self.session.commit()
        await self.session.refresh(digest)
        
        return digest
    
    async def enrich_digest_with_content(self, digest: DailyDigest) -> DigestResponse:
        """
        Enrichit le digest avec les détails des contenus.
        """
        # Get all content IDs
        content_ids = [item["content_id"] for item in digest.items]
        
        # Fetch contents with sources
        result = await self.session.execute(
            select(Content)
            .options(selectinload(Content.source))
            .where(Content.id.in_(content_ids))
        )
        contents = {str(c.id): c for c in result.scalars().all()}
        
        # Build response items
        items = []
        total_duration = 0
        has_curated = False
        
        for item_data in digest.items:
            content = contents.get(item_data["content_id"])
            if not content:
                continue
            
            total_duration += content.duration_seconds or 180  # Default 3 min
            
            if item_data.get("is_curated_fallback"):
                has_curated = True
            
            items.append(DigestItemResponse(
                rank=item_data["rank"],
                status=item_data["status"],
                digest_reason=item_data["digest_reason"],
                actioned_at=item_data.get("actioned_at"),
                content=ContentSummary(
                    id=content.id,
                    title=content.title,
                    url=content.url,
                    thumbnail_url=content.thumbnail_url,
                    description=content.description,
                    published_at=content.published_at,
                    duration_seconds=content.duration_seconds,
                    content_type=content.content_type,
                    source=SourceSummary(
                        id=content.source.id,
                        name=content.source.name,
                        logo_url=content.source.logo_url,
                        theme=content.source.theme,
                    )
                )
            ))
        
        return DigestResponse(
            digest_date=digest.digest_date,
            generated_at=digest.generated_at,
            progress=digest.progress,
            is_complete=digest.is_complete,
            estimated_reading_time_minutes=total_duration // 60,
            has_curated_fallback=has_curated,
            items=items,
        )
```

### Schémas Pydantic

```python
# packages/api/app/schemas/digest.py

from datetime import date, datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel


class SourceSummary(BaseModel):
    id: UUID
    name: str
    logo_url: Optional[str]
    theme: str


class ContentSummary(BaseModel):
    id: UUID
    title: str
    url: str
    thumbnail_url: Optional[str]
    description: Optional[str]
    published_at: Optional[datetime]
    duration_seconds: Optional[int]
    content_type: str
    source: SourceSummary


class DigestItemResponse(BaseModel):
    rank: int
    status: str  # pending, read, saved
    digest_reason: str
    actioned_at: Optional[datetime]
    content: ContentSummary


class DigestResponse(BaseModel):
    digest_date: date
    generated_at: datetime
    progress: str  # "2/5"
    is_complete: bool
    estimated_reading_time_minutes: int
    has_curated_fallback: bool
    items: List[DigestItemResponse]
```

### Références Architecture

- [Source: routers/feed_router.py] — Pattern de router existant
- [Source: services/briefing_service.py] — Service existant similaire

## Testing

- **Unit Tests** : `tests/routers/test_digest_router.py`
  - Test endpoint retourne 200 avec digest
  - Test génération lazy si pas de digest
  - Test 401 si non authentifié
- **Integration** : Test E2E avec DB

## Definition of Done

- [ ] Endpoint `GET /api/digest` fonctionnel
- [ ] Génération lazy implémentée
- [ ] Schémas de réponse créés
- [ ] Tests passent
- [ ] Documentation Swagger générée

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
