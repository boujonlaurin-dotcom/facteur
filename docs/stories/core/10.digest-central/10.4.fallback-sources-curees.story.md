# Story 10.4 : Fallback Sources Curées

## Status: Draft

## Story

**As a** utilisateur avec peu de sources déclarées,  
**I want** que mon digest soit complété par des sources curées alignées sur mes thèmes,  
**so that** j'aie toujours 5 articles de qualité chaque jour.

## Acceptance Criteria

1. **Activation automatique** si le pool des sources déclarées retourne < 5 articles
2. **Sélection intelligente** des sources curées :
   - Alignées sur les thèmes d'intérêt de l'utilisateur (`user_interests`)
   - Status `CURATED` uniquement
   - Non déjà dans le pool utilisateur
3. **Même scoring** appliqué aux articles des sources curées
4. **Transparence** : `digest_reason` = "Suggestion qualité" pour les articles curés
5. **Message UI** : Notification à l'utilisateur que des suggestions ont été ajoutées

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Créer la méthode `_get_fallback_sources`**
  - [ ] Récupérer les sources `CURATED` non suivies
  - [ ] Filtrer par thèmes matchant `user_interests`
  - [ ] Trier par `score_independence + score_rigor` (FQS)
  - [ ] Retourner les source_ids

- [ ] **Task 2: Étendre `select_digest` avec fallback**
  - [ ] Après sélection avec contraintes, vérifier `len(selected) < 5`
  - [ ] Si oui, récupérer candidats supplémentaires des sources curées
  - [ ] Appliquer le même scoring et contraintes
  - [ ] Compléter jusqu'à 5 articles

- [ ] **Task 3: Marquer les articles curés**
  - [ ] Ajouter flag `is_curated_fallback` dans le DigestItem
  - [ ] `digest_reason` = "Suggestion qualité"
  - [ ] Permettre au frontend de différencier

- [ ] **Task 4: Logging du fallback**
  - [ ] Logger quand le fallback est activé
  - [ ] Logger le nombre d'articles ajoutés
  - [ ] Logger les sources curées utilisées

## Dev Notes

### Extension du DigestSelector

```python
# Ajout dans packages/api/app/services/digest_selector.py

class DigestSelector:
    # ... (code existant) ...
    
    async def select_digest(self, user_id: UUID) -> list[DigestItem]:
        """
        Sélectionne les 5 meilleurs articles avec fallback curées.
        """
        # ... (étapes 1-6 existantes) ...
        
        # 7. Fallback si < 5 articles (NOUVEAU)
        if len(diverse_selection) < self.TARGET_DIGEST_SIZE:
            logger.info(
                "Activating curated fallback",
                current_count=len(diverse_selection),
                target=self.TARGET_DIGEST_SIZE,
                user_id=str(user_id)
            )
            diverse_selection = await self._apply_curated_fallback(
                user_id=user_id,
                current_selection=diverse_selection,
                user_themes=user_themes,
                consumed_ids=consumed_ids,
            )
        
        # 8. Build DigestItem list
        return self._build_digest_items(diverse_selection)
    
    async def _apply_curated_fallback(
        self,
        user_id: UUID,
        current_selection: list[dict],
        user_themes: set[str],
        consumed_ids: set[UUID],
    ) -> list[dict]:
        """
        Complète la sélection avec des articles de sources curées.
        """
        needed = self.TARGET_DIGEST_SIZE - len(current_selection)
        if needed <= 0:
            return current_selection
        
        # Get user's followed sources to exclude them
        user_source_ids = await self._get_user_source_ids(user_id)
        
        # Get curated sources matching user themes
        fallback_sources = await self._get_fallback_sources(user_themes, user_source_ids)
        
        if not fallback_sources:
            logger.warning("No curated fallback sources available", user_id=str(user_id))
            return current_selection
        
        # Get candidates from curated sources
        fallback_candidates = await self._get_candidates(fallback_sources, consumed_ids)
        
        # Score them
        scored_fallback = self._score_candidates(fallback_candidates, user_themes)
        scored_fallback.sort(key=lambda x: x["score"], reverse=True)
        
        # Mark as curated fallback
        for item in scored_fallback:
            item["is_curated_fallback"] = True
        
        # Apply diversity constraints on fallback
        # Use existing source/theme counts from current selection
        source_count = {}
        theme_count = {}
        for item in current_selection:
            content = item["content"]
            source_count[content.source_id] = source_count.get(content.source_id, 0) + 1
            theme_count[content.source.theme] = theme_count.get(content.source.theme, 0) + 1
        
        # Add fallback articles respecting constraints
        for item in scored_fallback:
            if len(current_selection) >= self.TARGET_DIGEST_SIZE:
                break
            
            content = item["content"]
            source_id = content.source_id
            theme = content.source.theme
            
            if source_count.get(source_id, 0) >= self.MAX_PER_SOURCE:
                continue
            if theme_count.get(theme, 0) >= self.MAX_PER_THEME:
                continue
            
            current_selection.append(item)
            source_count[source_id] = source_count.get(source_id, 0) + 1
            theme_count[theme] = theme_count.get(theme, 0) + 1
        
        logger.info(
            "Curated fallback applied",
            final_count=len(current_selection),
            fallback_added=len(current_selection) - (self.TARGET_DIGEST_SIZE - needed)
        )
        
        return current_selection
    
    async def _get_fallback_sources(
        self, 
        user_themes: set[str], 
        exclude_source_ids: set[UUID]
    ) -> set[UUID]:
        """
        Récupère les sources curées matchant les thèmes utilisateur.
        """
        result = await self.session.execute(
            select(Source.id)
            .where(
                and_(
                    Source.status == "CURATED",
                    Source.theme.in_(user_themes) if user_themes else True,
                    not_(Source.id.in_(exclude_source_ids)) if exclude_source_ids else True
                )
            )
            .order_by(
                (Source.score_independence + Source.score_rigor).desc()
            )
            .limit(10)  # Top 10 curated sources
        )
        return set(row[0] for row in result.fetchall())
    
    def _determine_reason(self, item: dict) -> str:
        """Détermine la raison du digest."""
        if item.get("is_curated_fallback"):
            return "Suggestion qualité"
        
        # ... (logique existante) ...
```

### Exemple de fallback

**Situation :** Utilisateur suit 2 sources → 3 articles disponibles

| Source suivie | Articles |
|---------------|----------|
| TechCrunch | 2 |
| Le Monde | 1 |
| **Total** | **3** |

**Fallback activé :** Ajout de 2 articles depuis sources curées alignées sur les thèmes.

| Source | Type | Articles |
|--------|------|----------|
| TechCrunch | Suivie | 2 |
| Le Monde | Suivie | 1 |
| France Info | Curée | 1 |
| Les Échos | Curée | 1 |
| **Total** | — | **5** |

### Références Architecture

- [Source: architecture.md#source-status] — Status CURATED
- [Source: 3.1.modele-donnees-sources-contenus.md] — FQS scores

## Testing

- **Unit Tests** : `tests/services/test_digest_selector.py`
  - Test fallback activé quand < 5
  - Test sources curées alignées sur thèmes
  - Test contraintes respectées sur fallback
  - Test `digest_reason` = "Suggestion qualité"

## Definition of Done

- [ ] Fallback curées implémenté
- [ ] `digest_reason` correctement marqué
- [ ] Tests unitaires passent
- [ ] Logging en place

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
