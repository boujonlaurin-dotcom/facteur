# Story 10.6 : Endpoint POST /api/digest/{content_id}/action

## Status: Draft

## Story

**As a** application mobile,  
**I want** marquer un article du digest comme "lu" ou "sauvegardé",  
**so that** la progression soit trackée et la closure détectée.

## Acceptance Criteria

1. **Endpoint `POST /api/digest/{content_id}/action`** accepte une action
2. **Actions supportées** : `read` ou `saved`
3. **Mise à jour du statut** de l'item dans `daily_digest.items`
4. **Incrémentation automatique** de `items_actioned`
5. **Détection de closure** : si `items_actioned == 5`, marquer `is_complete = true`
6. **Retour de la progression** mise à jour
7. **Idempotence** : ré-actionner un item déjà actionné ne change rien

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Créer le schéma de requête**
  - [ ] `DigestActionRequest` : action (read | saved)
  - [ ] Validation avec Enum

- [ ] **Task 2: Créer l'endpoint**
  - [ ] Route `POST /api/digest/{content_id}/action`
  - [ ] Validation que le content_id est dans le digest du jour
  - [ ] Mise à jour atomique du JSONB

- [ ] **Task 3: Implémenter la logique de mise à jour**
  - [ ] Trouver l'item par content_id
  - [ ] Vérifier status == "pending" (sinon ignorer)
  - [ ] Mettre à jour status et actioned_at
  - [ ] Incrémenter items_actioned
  - [ ] Vérifier si closure atteinte

- [ ] **Task 4: Créer le schéma de réponse**
  - [ ] `DigestActionResponse` : success, new_status, progress, is_complete

- [ ] **Task 5: Gérer les cas d'erreur**
  - [ ] 404 si content_id pas dans le digest
  - [ ] 400 si action invalide

## Dev Notes

### Spécification API

```yaml
POST /api/digest/{content_id}/action
Authorization: Bearer <jwt>
Content-Type: application/json

Request:
{
  "action": "read"  // ou "saved"
}

Response 200:
{
  "success": true,
  "new_status": "read",
  "progress": "3/5",
  "is_complete": false,
  "closure_triggered": false
}

Response 200 (closure):
{
  "success": true,
  "new_status": "saved",
  "progress": "5/5",
  "is_complete": true,
  "closure_triggered": true,
  "time_to_complete_seconds": 245
}

Response 404:
{
  "detail": "Content not found in today's digest"
}

Response 400:
{
  "detail": "Invalid action. Must be 'read' or 'saved'"
}
```

### Implémentation Router

```python
# Ajout dans packages/api/app/routers/digest_router.py

from uuid import UUID
from app.schemas.digest import DigestActionRequest, DigestActionResponse


@router.post("/{content_id}/action", response_model=DigestActionResponse)
async def action_digest_item(
    content_id: UUID,
    request: DigestActionRequest,
    user_id: str = Depends(get_current_user),
    session: AsyncSession = Depends(get_session),
):
    """
    Marque un article du digest comme lu ou sauvegardé.
    
    Déclenche la closure si tous les articles sont actionnés.
    """
    service = DigestService(session)
    
    result = await service.action_item(
        user_id=UUID(user_id),
        content_id=content_id,
        action=request.action,
    )
    
    if result is None:
        raise HTTPException(
            status_code=404, 
            detail="Content not found in today's digest"
        )
    
    return result
```

### Implémentation Service

```python
# Ajout dans packages/api/app/services/digest_service.py

from datetime import datetime
from app.schemas.digest import DigestActionRequest, DigestActionResponse


class DigestService:
    # ... (code existant) ...
    
    async def action_item(
        self, 
        user_id: UUID, 
        content_id: UUID, 
        action: str
    ) -> Optional[DigestActionResponse]:
        """
        Marque un item du digest comme lu ou sauvegardé.
        
        Returns:
            DigestActionResponse ou None si content non trouvé.
        """
        today = date.today()
        
        # Get today's digest
        result = await self.session.execute(
            select(DailyDigest).where(
                DailyDigest.user_id == user_id,
                DailyDigest.digest_date == today
            )
        )
        digest = result.scalar_one_or_none()
        
        if not digest:
            return None
        
        # Find the item
        item_found = False
        was_pending = False
        
        for item in digest.items:
            if item["content_id"] == str(content_id):
                item_found = True
                
                # Idempotence: only update if pending
                if item["status"] == "pending":
                    was_pending = True
                    item["status"] = action
                    item["actioned_at"] = datetime.utcnow().isoformat()
                    digest.items_actioned += 1
                    
                    # Check for closure
                    if digest.items_actioned >= digest.total_items:
                        digest.is_complete = True
                        digest.completed_at = datetime.utcnow()
                
                break
        
        if not item_found:
            return None
        
        # Persist changes
        await self.session.commit()
        
        # Calculate time to complete if closure
        time_to_complete = None
        if digest.is_complete and digest.completed_at:
            time_to_complete = int(
                (digest.completed_at - digest.generated_at).total_seconds()
            )
        
        return DigestActionResponse(
            success=True,
            new_status=action if was_pending else "already_actioned",
            progress=digest.progress,
            is_complete=digest.is_complete,
            closure_triggered=was_pending and digest.is_complete,
            time_to_complete_seconds=time_to_complete,
        )
```

### Schémas Pydantic

```python
# Ajout dans packages/api/app/schemas/digest.py

from enum import Enum


class DigestAction(str, Enum):
    READ = "read"
    SAVED = "saved"


class DigestActionRequest(BaseModel):
    action: DigestAction


class DigestActionResponse(BaseModel):
    success: bool
    new_status: str
    progress: str
    is_complete: bool
    closure_triggered: bool
    time_to_complete_seconds: Optional[int] = None
```

### Mise à jour user_content_status

En plus de mettre à jour le digest, l'action doit aussi mettre à jour `user_content_status` pour la cohérence :

```python
# Dans action_item, après la mise à jour du digest

if was_pending:
    # Update user_content_status for consistency
    await self._update_content_status(
        user_id=user_id,
        content_id=content_id,
        status="consumed" if action == "read" else "saved"
    )

async def _update_content_status(
    self, 
    user_id: UUID, 
    content_id: UUID, 
    status: str
):
    """Met à jour le statut du contenu pour l'utilisateur."""
    from app.models import UserContentStatus
    
    result = await self.session.execute(
        select(UserContentStatus).where(
            UserContentStatus.user_id == user_id,
            UserContentStatus.content_id == content_id
        )
    )
    content_status = result.scalar_one_or_none()
    
    if content_status:
        content_status.status = status
        if status == "saved":
            content_status.is_saved = True
    else:
        content_status = UserContentStatus(
            user_id=user_id,
            content_id=content_id,
            status=status,
            is_saved=(status == "saved"),
        )
        self.session.add(content_status)
```

### Références Architecture

- [Source: routers/feed_router.py] — Pattern endpoints existants
- [Source: 4.4.top3-briefing-quotidien.story.md] — Endpoint consumed existant

## Testing

- **Unit Tests** : `tests/routers/test_digest_router.py`
  - Test action "read" met à jour le statut
  - Test action "saved" met à jour le statut
  - Test idempotence (re-action n'incrémente pas)
  - Test closure détectée à 5/5
  - Test 404 si content non trouvé

## Definition of Done

- [ ] Endpoint `POST /api/digest/{id}/action` fonctionnel
- [ ] Actions read/saved supportées
- [ ] Closure détectée automatiquement
- [ ] user_content_status mis à jour en parallèle
- [ ] Tests passent

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
