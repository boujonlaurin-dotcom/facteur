# Story 10.9 : Écran Digest Flutter

## Status: Draft

## Story

**As a** utilisateur,  
**I want** voir un écran dédié affichant mes 5 articles du jour,  
**so that** je puisse les traiter rapidement et atteindre la closure.

## Acceptance Criteria

1. **Écran principal** remplace le feed comme home screen
2. **Header** affiche "L'Essentiel" + date du jour + temps de lecture estimé
3. **Liste de 5 cartes** affichées verticalement (pas de scroll infini)
4. **Barre de progression** visible (Story 10.11)
5. **Lien "Explorer plus"** discret en bas (Story 10.14)
6. **États gérés** : loading, error, empty (pas de digest)
7. **Pull-to-refresh** pour recharger le digest

## Tasks / Subtasks

### Frontend Mobile

- [ ] **Task 1: Créer le screen `DigestScreen`**
  - [ ] Fichier `apps/mobile/lib/features/digest/screens/digest_screen.dart`
  - [ ] Consumer Riverpod pour le state
  - [ ] Scaffold avec AppBar personnalisée

- [ ] **Task 2: Créer le provider `digestProvider`**
  - [ ] Fichier `apps/mobile/lib/features/digest/providers/digest_provider.dart`
  - [ ] `AsyncNotifier<DigestState>` avec méthodes :
    - `build()` : charge le digest
    - `actionItem(contentId, action)` : marque lu/sauvegardé
    - `refresh()` : recharge le digest

- [ ] **Task 3: Créer le repository `DigestRepository`**
  - [ ] Fichier `apps/mobile/lib/features/digest/data/digest_repository.dart`
  - [ ] Méthodes :
    - `getDigest()` → `DigestResponse`
    - `actionItem(contentId, action)` → `ActionResponse`

- [ ] **Task 4: Créer les modèles Dart**
  - [ ] `DigestResponse`, `DigestItem`, `ContentSummary`
  - [ ] Parsing JSON

- [ ] **Task 5: Implémenter le layout**
  - [ ] Header avec date et temps
  - [ ] ListView.builder pour les 5 cartes
  - [ ] Barre de progression (placeholder pour Story 10.11)
  - [ ] Lien "Explorer plus" (placeholder pour Story 10.14)

- [ ] **Task 6: Gérer les états**
  - [ ] Loading : Shimmer skeleton
  - [ ] Error : Message + bouton retry
  - [ ] Empty : Message "Ton digest arrive bientôt"

- [ ] **Task 7: Modifier la navigation**
  - [ ] DigestScreen devient la route home `/`
  - [ ] FeedScreen accessible via `/feed`

## Dev Notes

### Architecture Flutter

```
apps/mobile/lib/features/digest/
├── screens/
│   └── digest_screen.dart        # Écran principal
├── widgets/
│   ├── digest_header.dart        # Header avec date/temps
│   ├── digest_card.dart          # Carte article (Story 10.10)
│   ├── digest_progress_bar.dart  # Barre progression (Story 10.11)
│   └── explore_more_link.dart    # Lien feed (Story 10.14)
├── providers/
│   └── digest_provider.dart      # State management
├── data/
│   └── digest_repository.dart    # API calls
└── models/
    ├── digest_response.dart
    └── digest_item.dart
```

### DigestScreen

```dart
// apps/mobile/lib/features/digest/screens/digest_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class DigestScreen extends ConsumerWidget {
  const DigestScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final digestAsync = ref.watch(digestProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('L\'Essentiel'),
        centerTitle: true,
        actions: [
          // Streak badge (Story 10.13)
          _buildStreakBadge(ref),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () => ref.read(digestProvider.notifier).refresh(),
        child: digestAsync.when(
          loading: () => const DigestSkeleton(),
          error: (e, _) => DigestError(
            message: e.toString(),
            onRetry: () => ref.invalidate(digestProvider),
          ),
          data: (digest) => DigestContent(digest: digest),
        ),
      ),
    );
  }

  Widget _buildStreakBadge(WidgetRef ref) {
    // Placeholder - implémenté Story 10.13
    return const SizedBox.shrink();
  }
}

class DigestContent extends StatelessWidget {
  final DigestResponse digest;

  const DigestContent({super.key, required this.digest});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Header avec date et temps
        DigestHeader(
          date: digest.digestDate,
          estimatedMinutes: digest.estimatedReadingTimeMinutes,
        ),
        
        // Barre de progression
        DigestProgressBar(
          current: digest.itemsActioned,
          total: digest.totalItems,
        ),
        
        // Liste des 5 articles
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            itemCount: digest.items.length,
            itemBuilder: (context, index) {
              final item = digest.items[index];
              return DigestCard(
                item: item,
                onAction: (action) {
                  // Handled by provider
                },
              );
            },
          ),
        ),
        
        // Lien "Explorer plus" (discret)
        const ExploreMoreLink(),
        
        const SizedBox(height: 16),
      ],
    );
  }
}
```

### DigestProvider

```dart
// apps/mobile/lib/features/digest/providers/digest_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

final digestProvider = AsyncNotifierProvider<DigestNotifier, DigestState>(
  DigestNotifier.new,
);

class DigestState {
  final DigestResponse? digest;
  final bool isClosureTriggered;

  DigestState({this.digest, this.isClosureTriggered = false});
}

class DigestNotifier extends AsyncNotifier<DigestState> {
  late final DigestRepository _repository;

  @override
  Future<DigestState> build() async {
    _repository = ref.read(digestRepositoryProvider);
    
    final digest = await _repository.getDigest();
    return DigestState(digest: digest);
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final digest = await _repository.getDigest();
      return DigestState(digest: digest);
    });
  }

  Future<void> actionItem(String contentId, String action) async {
    final currentDigest = state.value?.digest;
    if (currentDigest == null) return;

    // Optimistic update
    _updateItemOptimistically(contentId, action);

    try {
      final response = await _repository.actionItem(contentId, action);
      
      if (response.closureTriggered) {
        // Trigger closure animation
        state = AsyncValue.data(DigestState(
          digest: _getUpdatedDigest(response),
          isClosureTriggered: true,
        ));
      }
    } catch (e) {
      // Rollback on error
      state = AsyncValue.data(DigestState(digest: currentDigest));
      rethrow;
    }
  }

  void _updateItemOptimistically(String contentId, String action) {
    final currentDigest = state.value?.digest;
    if (currentDigest == null) return;

    final updatedItems = currentDigest.items.map((item) {
      if (item.content.id == contentId && item.status == 'pending') {
        return item.copyWith(status: action);
      }
      return item;
    }).toList();

    state = AsyncValue.data(DigestState(
      digest: currentDigest.copyWith(
        items: updatedItems,
        itemsActioned: currentDigest.itemsActioned + 1,
      ),
    ));
  }
}
```

### DigestRepository

```dart
// apps/mobile/lib/features/digest/data/digest_repository.dart

import 'package:dio/dio.dart';

final digestRepositoryProvider = Provider<DigestRepository>((ref) {
  final dio = ref.read(dioProvider);
  return DigestRepository(dio);
});

class DigestRepository {
  final Dio _dio;

  DigestRepository(this._dio);

  Future<DigestResponse> getDigest() async {
    final response = await _dio.get('/api/digest');
    return DigestResponse.fromJson(response.data);
  }

  Future<ActionResponse> actionItem(String contentId, String action) async {
    final response = await _dio.post(
      '/api/digest/$contentId/action',
      data: {'action': action},
    );
    return ActionResponse.fromJson(response.data);
  }
}
```

### Modèles Dart

```dart
// apps/mobile/lib/features/digest/models/digest_response.dart

import 'package:freezed_annotation/freezed_annotation.dart';

part 'digest_response.freezed.dart';
part 'digest_response.g.dart';

@freezed
class DigestResponse with _$DigestResponse {
  const factory DigestResponse({
    required DateTime digestDate,
    required DateTime generatedAt,
    required String progress,
    required bool isComplete,
    required int estimatedReadingTimeMinutes,
    required bool hasCuratedFallback,
    required List<DigestItem> items,
    required int closureStreak,
    required int longestClosureStreak,
  }) = _DigestResponse;

  factory DigestResponse.fromJson(Map<String, dynamic> json) =>
      _$DigestResponseFromJson(json);
  
  int get itemsActioned => items.where((i) => i.status != 'pending').length;
  int get totalItems => items.length;
}

@freezed
class DigestItem with _$DigestItem {
  const factory DigestItem({
    required int rank,
    required String status,
    required String digestReason,
    DateTime? actionedAt,
    required ContentSummary content,
  }) = _DigestItem;

  factory DigestItem.fromJson(Map<String, dynamic> json) =>
      _$DigestItemFromJson(json);
}

@freezed
class ContentSummary with _$ContentSummary {
  const factory ContentSummary({
    required String id,
    required String title,
    required String url,
    String? thumbnailUrl,
    String? description,
    DateTime? publishedAt,
    int? durationSeconds,
    required String contentType,
    required SourceSummary source,
  }) = _ContentSummary;

  factory ContentSummary.fromJson(Map<String, dynamic> json) =>
      _$ContentSummaryFromJson(json);
}
```

### Navigation

```dart
// Modification dans apps/mobile/lib/config/router.dart

GoRoute(
  path: '/',
  name: 'digest',
  builder: (context, state) => const DigestScreen(),
),
GoRoute(
  path: '/feed',
  name: 'feed',
  builder: (context, state) => const FeedScreen(),
),
```

### Références Architecture

- [Source: feed_screen.dart] — Pattern écran existant
- [Source: feed_provider.dart] — Pattern provider existant

## Testing

- **Widget Tests** : `test/features/digest/digest_screen_test.dart`
  - Test affichage 5 cartes
  - Test états loading/error/empty
  - Test refresh fonctionne

## Definition of Done

- [ ] DigestScreen créé et fonctionnel
- [ ] Provider et Repository implémentés
- [ ] Modèles Dart avec parsing JSON
- [ ] Navigation mise à jour
- [ ] États loading/error/empty gérés
- [ ] Pull-to-refresh fonctionne

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
