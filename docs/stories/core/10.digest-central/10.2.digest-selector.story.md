# Story 10.2 : DigestSelector — Pool Sources Déclarées

## Status: Draft

## Story

**As a** système,  
**I want** sélectionner les 5 meilleurs articles UNIQUEMENT parmi les sources déclarées par l'utilisateur,  
**so that** le digest respecte la promesse "tes sources, pas les nôtres".

## Acceptance Criteria

1. **Pool strictement limité** aux sources dans `user_sources` (suivies par l'utilisateur)
2. **Fenêtre temporelle** de 36h glissantes pour les candidats
3. **Exclusion automatique** des contenus déjà consommés (`user_content_status`)
4. **Scoring déterministe** sans ML (règles explicites)
5. **Retour de 5 articles** avec `digest_reason` pour chaque
6. **Intégration** avec le job CRON existant (8h Paris)

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Créer le service `DigestSelector`**
  - [ ] Fichier `packages/api/app/services/digest_selector.py`
  - [ ] Classe `DigestSelector` avec méthode principale `select_digest(user_id) -> list[DigestItem]`
  - [ ] Injection de dépendances (session DB)

- [ ] **Task 2: Implémenter la récupération du pool**
  - [ ] Requête sur `user_sources` pour obtenir les source_ids suivies
  - [ ] Requête sur `contents` filtré par :
    - `source_id IN user_sources`
    - `published_at >= now() - 36h`
    - `content_id NOT IN consumed_content_ids`
  - [ ] Logging du nombre de candidats

- [ ] **Task 3: Implémenter le scoring déterministe**
  - [ ] Boost thème déclaré : +50 points si `source.theme IN user_interests`
  - [ ] Boost fraîcheur : +30 points si `published_at > now() - 12h`
  - [ ] Boost "À la Une" : +40 points si `from_une_feed = true`
  - [ ] Boost trending : +35 points si `is_trending = true`
  - [ ] Boost qualité FQS : +15 points si `source.reliability_score = HIGH`
  - [ ] Malus qualité FQS : -30 points si `source.reliability_score = LOW`

- [ ] **Task 4: Générer les `digest_reason`**
  - [ ] "Source suivie" — si source dans `user_sources` (toujours le cas)
  - [ ] "À la Une" — si `from_une_feed = true`
  - [ ] "Sujet tendance" — si `is_trending = true`
  - [ ] "Thème favori" — si thème matche `user_interests`
  - [ ] Priorité : Une > Tendance > Thème > Suivie

- [ ] **Task 5: Sélectionner les 5 meilleurs**
  - [ ] Trier par `digest_score` décroissant
  - [ ] Prendre les 5 premiers (avant contraintes diversité — Story 10.3)
  - [ ] Retourner liste de `DigestItem`

## Dev Notes

### Architecture du service

```python
# packages/api/app/services/digest_selector.py

from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID

import structlog
from sqlalchemy import select, and_, not_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import Content, Source, UserSource, UserInterest, UserContentStatus
from app.schemas.digest import DigestItem

logger = structlog.get_logger()


class DigestSelector:
    """
    Sélectionne les 5 meilleurs articles pour le digest quotidien.
    
    Pool: UNIQUEMENT les sources déclarées par l'utilisateur.
    Scoring: Règles déterministes (pas de ML).
    """
    
    # Scoring weights
    BOOST_THEME_MATCH = 50
    BOOST_FRESHNESS = 30
    BOOST_UNE = 40
    BOOST_TRENDING = 35
    BOOST_QUALITY_HIGH = 15
    MALUS_QUALITY_LOW = -30
    
    # Time windows
    CANDIDATE_WINDOW_HOURS = 36
    FRESHNESS_WINDOW_HOURS = 12
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def select_digest(self, user_id: UUID) -> list[DigestItem]:
        """
        Sélectionne les 5 meilleurs articles pour l'utilisateur.
        
        Returns:
            Liste de 5 DigestItem maximum.
        """
        # 1. Get user's followed sources
        user_source_ids = await self._get_user_source_ids(user_id)
        if not user_source_ids:
            logger.warning("No sources followed", user_id=str(user_id))
            return []
        
        # 2. Get user's interests (themes)
        user_themes = await self._get_user_themes(user_id)
        
        # 3. Get consumed content IDs
        consumed_ids = await self._get_consumed_content_ids(user_id)
        
        # 4. Get candidate contents
        candidates = await self._get_candidates(user_source_ids, consumed_ids)
        logger.info("Candidates found", count=len(candidates), user_id=str(user_id))
        
        # 5. Score each candidate
        scored = self._score_candidates(candidates, user_themes)
        
        # 6. Sort and select top 5
        scored.sort(key=lambda x: x["score"], reverse=True)
        top_5 = scored[:5]
        
        # 7. Build DigestItem list
        return [
            DigestItem(
                content_id=item["content"].id,
                rank=idx + 1,
                status="pending",
                digest_reason=self._determine_reason(item),
            )
            for idx, item in enumerate(top_5)
        ]
    
    async def _get_user_source_ids(self, user_id: UUID) -> set[UUID]:
        """Récupère les IDs des sources suivies par l'utilisateur."""
        result = await self.session.execute(
            select(UserSource.source_id).where(UserSource.user_id == user_id)
        )
        return set(row[0] for row in result.fetchall())
    
    async def _get_user_themes(self, user_id: UUID) -> set[str]:
        """Récupère les thèmes d'intérêt de l'utilisateur."""
        result = await self.session.execute(
            select(UserInterest.interest_slug).where(UserInterest.user_id == user_id)
        )
        return set(row[0] for row in result.fetchall())
    
    async def _get_consumed_content_ids(self, user_id: UUID) -> set[UUID]:
        """Récupère les IDs des contenus déjà consommés."""
        result = await self.session.execute(
            select(UserContentStatus.content_id).where(
                and_(
                    UserContentStatus.user_id == user_id,
                    UserContentStatus.status.in_(["consumed", "seen"])
                )
            )
        )
        return set(row[0] for row in result.fetchall())
    
    async def _get_candidates(
        self, 
        source_ids: set[UUID], 
        consumed_ids: set[UUID]
    ) -> list[Content]:
        """Récupère les contenus candidats."""
        cutoff = datetime.utcnow() - timedelta(hours=self.CANDIDATE_WINDOW_HOURS)
        
        query = (
            select(Content)
            .join(Source, Content.source_id == Source.id)
            .where(
                and_(
                    Content.source_id.in_(source_ids),
                    Content.published_at >= cutoff,
                    not_(Content.id.in_(consumed_ids)) if consumed_ids else True
                )
            )
            .options(selectinload(Content.source))
        )
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    def _score_candidates(
        self, 
        candidates: list[Content], 
        user_themes: set[str]
    ) -> list[dict]:
        """Calcule le score de chaque candidat."""
        now = datetime.utcnow()
        freshness_cutoff = now - timedelta(hours=self.FRESHNESS_WINDOW_HOURS)
        
        scored = []
        for content in candidates:
            score = 0
            flags = {
                "theme_match": False,
                "is_fresh": False,
                "from_une": False,
                "is_trending": False,
            }
            
            # Theme match
            if content.source.theme in user_themes:
                score += self.BOOST_THEME_MATCH
                flags["theme_match"] = True
            
            # Freshness
            if content.published_at and content.published_at > freshness_cutoff:
                score += self.BOOST_FRESHNESS
                flags["is_fresh"] = True
            
            # À la Une
            if getattr(content, "from_une_feed", False):
                score += self.BOOST_UNE
                flags["from_une"] = True
            
            # Trending
            if getattr(content, "is_trending", False):
                score += self.BOOST_TRENDING
                flags["is_trending"] = True
            
            # Quality
            reliability = getattr(content.source, "reliability_score", None)
            if reliability == "HIGH":
                score += self.BOOST_QUALITY_HIGH
            elif reliability == "LOW":
                score += self.MALUS_QUALITY_LOW
            
            scored.append({
                "content": content,
                "score": score,
                "flags": flags,
            })
        
        return scored
    
    def _determine_reason(self, item: dict) -> str:
        """Détermine la raison du digest (priorité décroissante)."""
        flags = item["flags"]
        
        if flags["from_une"]:
            return "À la Une"
        if flags["is_trending"]:
            return "Sujet tendance"
        if flags["theme_match"]:
            return "Thème favori"
        return "Source suivie"
```

### Matrice de scoring

| Critère | Points | Condition |
|---------|--------|-----------|
| Thème match | +50 | `source.theme IN user_interests` |
| Fraîcheur | +30 | `published_at > now() - 12h` |
| À la Une | +40 | `from_une_feed = true` |
| Trending | +35 | `is_trending = true` |
| Qualité HIGH | +15 | `reliability_score = HIGH` |
| Qualité LOW | -30 | `reliability_score = LOW` |

### Références Architecture

- [Source: architecture.md#scoring-engine] — Patterns de scoring existants
- [Source: 4.4.top3-briefing-quotidien.story.md#top3selector] — Logique existante à étendre
- [Source: briefing_service.py] — Service existant à remplacer

## Testing

- **Unit Tests** : `tests/services/test_digest_selector.py`
  - Test pool vide → retourne []
  - Test scoring correct
  - Test exclusion contenus consommés
  - Test génération digest_reason

## Definition of Done

- [ ] Service `DigestSelector` créé et fonctionnel
- [ ] Scoring déterministe implémenté (6 critères)
- [ ] `digest_reason` généré pour chaque article
- [ ] Tests unitaires passent
- [ ] Logs structurés en place

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
