# Story 4.4: Top 3 — Briefing Quotidien

> ## ⚠️ Status: Deprecated by Epic 10
> 
> Cette story est marquée comme **obsolète** par Epic 10 "Digest Central" qui remplace le Top 3 par un Digest de 5 articles.
> 
> **Note pour le développeur** : La logique existante dans `briefing_service.py`, `Top3Selector`, et `DailyTop3` est fonctionnelle et doit servir de **base pour l'implémentation** du DigestSelector (Story 10.2). Réutiliser les patterns de scoring, détection "À la Une", génération lazy, et l'architecture de persistence.

## Original Status: Done ✅

## Story

**As a** utilisateur,  
**I want** recevoir chaque jour mes 3 articles les plus importants,  
**so that** je reste informé de l'essentiel sans être submergé.

## Acceptance Criteria

1. **Section Briefing** : En haut du feed, une section dédiée affiche exactement 3 articles du jour. Les cartes sont **identiques aux FeedCards** classiques, mais encadrées dans un **container premium** (background différencié, effet glassmorphism ou gradient subtil) [Source: brainstorm PM]
2. **Calcul quotidien** : Le Top 3 est généré une fois par jour (batch 8h Paris), pas en temps réel [Source: brainstorm PM]
3. **Pertinence personnalisée** : Le scoring réutilise l'algo existant (`ScoringEngine`) comme base [Source: 4.1.feed-algorithme.md]
4. **Importance objective** : Détection des sujets "breaking" via :
   - Flux RSS "Une" de sources référence (Le Monde, France Info, AFP, France 24, Radio France)
   - Consensus multi-sources (≥3 sources couvrant le même sujet)
5. **Diversité** : Maximum 1 article par source dans le Top 3 [Source: brainstorm PM]
6. **Quota source suivie** : Le slot #3 est **toujours réservé** à une source suivie par l'utilisateur (garantie de confiance) [Source: brainstorm PM]
7. **UX post-lecture** : Les cartes lues s'atténuent visuellement ; après les 3 lues, la section collapse avec message "Reviens demain à 8h" [Source: brainstorm PM]
8. **Exclusion doublon** : Les articles du Top 3 n'apparaissent pas dans le feed normal [Source: brainstorm PM]

## Tasks / Subtasks

### Backend

- [x] **Task 1: Modèle `DailyTop3`**
  - [x] Créer la migration : table `daily_top3` avec `user_id`, `content_id`, `rank`, `top3_reason`, `consumed`, `generated_at`
  - [x] Créer le modèle SQLAlchemy correspondant

- [x] **Task 2: Module `ImportanceDetector`**
  - [x] Ajouter champ `une_feed_url` sur `Source` (nullable, pour les sources avec flux Une)
  - [x] Parser les feeds Une et marquer les contenus avec `from_une_feed=True`
  - [x] Implémenter le clustering titres (Jaccard similarity, seuil 0.4) pour détecter les sujets multi-sources
  - [x] Marquer les contenus avec `is_trending=True` si cluster ≥ 3 sources

- [x] **Task 3: Module `Top3Selector`**
  - [x] Créer une classe isolée qui prend en entrée `List[ScoredContent]` + `user_followed_sources`
  - [x] Appliquer les contraintes : `published_at >= J-1 8h`, max 1/source
  - [x] Appliquer les boosts : `from_une_feed` (+30), `is_trending` (+40)
  - [x] **Slot #3 réservé** : Sélectionner le meilleur article parmi les sources suivies par l'user
  - [x] Retourner les 3 meilleurs avec `top3_reason` généré

- [x] **Task 4: Job CRON quotidien**
  - [x] Créer `generate_daily_top3_job()` dans APScheduler (8h Paris)
  - [x] Pour chaque user actif : calculer et persister le Top 3 dans `daily_top3`

- [x] **Task 5: API Endpoint**
  - [x] Modifier `GET /api/feed` pour inclure `top3: [...]` dans la réponse
  - [x] Exclure les `content_id` du Top 3 des `items` du feed
  - [x] Endpoint `POST /api/top3/{content_id}/consumed` pour marquer comme lu

### Frontend Mobile

- [x] **Task 6: Composant `BriefingSection`**
  - [x] Affichage vertical de 3 `BriefingCard` en haut du feed
  - [x] Titre "☕ L'Essentiel du Jour"
  - [x] Séparateur visuel avant le feed normal

- [x] **Task 7: Composant `BriefingCard`**
  - [x] État "non lu" : badge de rang, fond normal
  - [x] État "lu" : titre barré, check ✓
  - [x] Afficher `top3_reason` comme tag secondaire

- [x] **Task 8: Animation post-lecture**
  - [x] Logique de collapse intégrée dans FeedScreen
  - [x] Section disparaît si tous les items sont consommés

- [x] **Task 9: Intégration `FeedScreen`**
  - [x] FeedResponse inclut `briefing[]`
  - [x] FeedRepository parse le briefing
  - [x] FeedScreen affiche BriefingSection en position 0

## Dev Notes

### Architecture

```
┌─────────────────────────────────┐
│  ScoringEngine (existant)       │ ← Inchangé
│  - CoreLayer, QualityLayer...   │
└────────────┬────────────────────┘
             │ scored_contents[]
             ▼
┌─────────────────────────────────┐
│  ImportanceDetector (NOUVEAU)   │
│  - parse_une_feeds()            │
│  - detect_trending_clusters()   │
└────────────┬────────────────────┘
             │ importance_flags
             ▼
┌─────────────────────────────────┐
│  Top3Selector (NOUVEAU)         │
│  - apply_constraints()          │
│  - apply_boosts()               │
│  - select_top3()                │
└────────────┬────────────────────┘
             │ top3[]
             ▼
        DailyTop3 (DB)
```

### Sources "Une" de référence

| Source | Feed Une | Biais |
|--------|----------|-------|
| Le Monde | `https://www.lemonde.fr/rss/une.xml` | Centre |
| France Info | `https://www.francetvinfo.fr/titres.rss` | Centre |
| AFP | À vérifier (souvent restreint) | Factuel |
| France 24 | `https://www.france24.com/fr/rss` | Centre (public) |
| Radio France | `https://www.radiofrance.fr/rss` | Centre-gauche (public) |

### Logique de sélection Top 3

```python
def select_top3(scored: list, user_followed_sources: set) -> list:
    # Étape 1 : Appliquer boosts importance
    for c in scored:
        c.top3_score = c.base_score
        if c.from_une_feed:
            c.top3_score += 30  # Une boost
        if c.is_trending:
            c.top3_score += 40  # Trending boost
    
    # Étape 2 : Trier par score décroissant
    sorted_all = sorted(scored, key=lambda c: c.top3_score, reverse=True)
    
    # Étape 3 : Sélection slots #1 et #2 (meilleurs globaux, sources distinctes)
    top2 = []
    used_sources = set()
    for c in sorted_all:
        if c.source_id not in used_sources:
            top2.append(c)
            used_sources.add(c.source_id)
        if len(top2) == 2:
            break
    
    # Étape 4 : Slot #3 RÉSERVÉ aux sources suivies
    remaining = [c for c in sorted_all if c not in top2 and c.source_id not in used_sources]
    from_followed = [c for c in remaining if c.source_id in user_followed_sources]
    
    if from_followed:
        slot3 = from_followed[0]  # Meilleur des sources suivies
    else:
        slot3 = remaining[0] if remaining else None  # Fallback si aucune source suivie
    
    return top2 + [slot3] if slot3 else top2
```

> [!IMPORTANT]
> **Règle Quota** : Le slot #3 garantit la présence d'une source de confiance de l'utilisateur, renforçant la proposition de valeur de Facteur.

### Clustering Jaccard (pseudo-code)

```python
def jaccard(a: set, b: set) -> float:
    return len(a & b) / len(a | b) if a | b else 0

def detect_trending(contents: list[Content]) -> set[UUID]:
    clusters = []
    for c in contents:
        tokens = set(normalize(c.title).split())
        matched = False
        for cluster in clusters:
            if jaccard(tokens, cluster["tokens"]) > 0.4:
                cluster["contents"].append(c)
                matched = True
                break
        if not matched:
            clusters.append({"tokens": tokens, "contents": [c]})
    
    trending = set()
    for cluster in clusters:
        sources = set(c.source_id for c in cluster["contents"])
        if len(sources) >= 3:
            trending.update(c.id for c in cluster["contents"])
    return trending
```

## Testing

- **Unit Tests** : `tests/test_top3_selector.py`, `tests/test_importance_detector.py`
- **Integration** : Vérifier le job CRON en environnement staging
- **Manual** : Simuler des contenus "trending" et valider le boost

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 19/01/2026 | 1.0 | Initial Draft (brainstorm PM + Designer BMAD) | Antigravity |
| 19/01/2026 | 1.1 | Ajout règle Quota source suivie (slot #3 réservé) | Antigravity |
| 21/01/2026 | 2.0 | Implémentation complète backend + frontend + validation E2E | Antigravity |
