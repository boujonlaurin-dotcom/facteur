# Story 4.1: Algorithme de tri et personnalisation

## Status: Ready ✅

## Story

**As a** utilisateur,  
**I want** voir un feed personnalisé selon mes préférences,  
**so that** les contenus les plus pertinents apparaissent en premier.

## Acceptance Criteria

1. Endpoint API `/api/feed` GET avec la logique de tri [Source: prd.md#Story 4.1]
2. Algorithme de scoring combinant :
    - **Thèmes préférés** (poids fort) [Source: prd.md#Story 4.1]
    - **Fraîcheur du contenu** (decay function) [Source: prd.md#Story 4.1]
    - **Type de contenu** (poids selon préférences) [Source: prd.md#Story 4.1]
3. **Filtrage** : Exclusion stricte des contenus vus (`ContentStatus.SEEN`, `CONSUMED`) et masqués (`HIDDEN`) [Source: prd.md#Story 4.1]
4. **Pagination** : Support du limit/offset (par défaut 20 items) [Source: prd.md#Story 4.1]
5. **Diversité** : Prévenir la domination d'une source unique (Source Fatigue).


## Tasks / Subtasks

- [ ] **Task 1: Service de Scoring (`RecommendationService`)**
  - [ ] Calculer un `score` dynamique pour chaque contenu candidat.
  - [ ] Implémenter la logique de poids (User Interest x Content Theme).
  - [ ] Implémenter la dépréciation temporelle (Linear ou Exponential Decay).

- [ ] **Task 2: Optimisation SQL**
  - [ ] Créer une vue ou une requête optimisée pour joindre `Contents`, `UserSources`, `UserInterests`.
  - [ ] Utiliser `NOT EXISTS` pour exclure efficacement les `UserContentStatus` existants.

- [ ] **Task 3: API Endpoint**
  - [ ] Implémenter `GET /api/feed` dans `routers/feed.py`.
  - [ ] Intégrer la pagination.

## Dev Notes

### Algorithme simplifié (V1)
Score = (`ThemeMatch` * 50) + (`SourceAffinity` * 20) + (`RecencyScore` * 30)

- **ThemeMatch** : 1.0 si le thème du contenu matche un intérêt utilisateur, 0.0 sinon.
- **RecencyScore** : `1 / (hours_since_published + 2)` (donne un bonus aux news chaudes).
- **SourceAffinity** : 1.0 si `UserSource` existe, 0.5 si source globale (catalogue).

### Diversité (Reranking)
Pour éviter la saturation ("Mur Socialter"), une pénalité exponentielle est appliquée lors du tri final :
`FinalScore = Score * (PenaltyFactor ^ RepeatCount)`

- **PenaltyFactor** : ~0.85
- **RepeatCount** : Nombre de fois où la source est déjà apparue dans la liste ordonnée.


### Queries
Attention aux performances. L'exclusion des contenus vus (`LEFT JOIN ... WHERE id IS NULL`) est critique.

## Testing
- **Unit Tests** : `tests/test_feed_algo.py` pour valider que le scoring favorise les bons items.
- **Integration** : Caller `/api/feed` et vérifier que les contenus "vieux" ou "vus" n'apparaissent pas en premier.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 10/01/2026 | 1.0 | Initial Draft | BMad Master Agent |
| 11/01/2026 | 1.1 | Ajout de la logique de Diversité (Source Fatigue) | Antigravity |

