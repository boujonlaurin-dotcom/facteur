# Story 4.4: Top 3 ‚Äî Briefing Quotidien

## Status: Draft üìù

## Story

**As a** utilisateur,  
**I want** recevoir chaque jour mes 3 articles les plus importants,  
**so that** je reste inform√© de l'essentiel sans √™tre submerg√©.

## Acceptance Criteria

1. **Section Briefing** : En haut du feed, une section d√©di√©e affiche exactement 3 articles du jour. Les cartes sont **identiques aux FeedCards** classiques, mais encadr√©es dans un **container premium** (background diff√©renci√©, effet glassmorphism ou gradient subtil) [Source: brainstorm PM]
2. **Calcul quotidien** : Le Top 3 est g√©n√©r√© une fois par jour (batch 8h Paris), pas en temps r√©el [Source: brainstorm PM]
3. **Pertinence personnalis√©e** : Le scoring r√©utilise l'algo existant (`ScoringEngine`) comme base [Source: 4.1.feed-algorithme.md]
4. **Importance objective** : D√©tection des sujets "breaking" via :
   - Flux RSS "Une" de sources r√©f√©rence (Le Monde, France Info, AFP, France 24, Radio France)
   - Consensus multi-sources (‚â•3 sources couvrant le m√™me sujet)
5. **Diversit√©** : Maximum 1 article par source dans le Top 3 [Source: brainstorm PM]
6. **Quota source suivie** : Le slot #3 est **toujours r√©serv√©** √† une source suivie par l'utilisateur (garantie de confiance) [Source: brainstorm PM]
7. **UX post-lecture** : Les cartes lues s'att√©nuent visuellement ; apr√®s les 3 lues, la section collapse avec message "Reviens demain √† 8h" [Source: brainstorm PM]
8. **Exclusion doublon** : Les articles du Top 3 n'apparaissent pas dans le feed normal [Source: brainstorm PM]

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Mod√®le `DailyTop3`**
  - [ ] Cr√©er la migration : table `daily_top3` avec `user_id`, `content_id`, `rank`, `top3_reason`, `consumed`, `generated_at`
  - [ ] Cr√©er le mod√®le SQLAlchemy correspondant

- [ ] **Task 2: Module `ImportanceDetector`**
  - [ ] Ajouter champ `une_feed_url` sur `Source` (nullable, pour les sources avec flux Une)
  - [ ] Parser les feeds Une et marquer les contenus avec `from_une_feed=True`
  - [ ] Impl√©menter le clustering titres (Jaccard similarity, seuil 0.4) pour d√©tecter les sujets multi-sources
  - [ ] Marquer les contenus avec `is_trending=True` si cluster ‚â• 3 sources

- [ ] **Task 3: Module `Top3Selector`**
  - [ ] Cr√©er une classe isol√©e qui prend en entr√©e `List[ScoredContent]` + `user_followed_sources`
  - [ ] Appliquer les contraintes : `published_at >= J-1 8h`, max 1/source
  - [ ] Appliquer les boosts : `from_une_feed` (+30), `is_trending` (+40)
  - [ ] **Slot #3 r√©serv√©** : S√©lectionner le meilleur article parmi les sources suivies par l'user
  - [ ] Retourner les 3 meilleurs avec `top3_reason` g√©n√©r√©

- [ ] **Task 4: Job CRON quotidien**
  - [ ] Cr√©er `generate_daily_top3_job()` dans APScheduler (8h Paris)
  - [ ] Pour chaque user actif : calculer et persister le Top 3 dans `daily_top3`

- [ ] **Task 5: API Endpoint**
  - [ ] Modifier `GET /api/feed` pour inclure `top3: [...]` dans la r√©ponse
  - [ ] Exclure les `content_id` du Top 3 des `items` du feed
  - [ ] Endpoint `POST /api/top3/{content_id}/consumed` pour marquer comme lu

### Frontend Mobile

- [ ] **Task 6: Composant `BriefingSection`**
  - [ ] Affichage vertical de 3 `BriefingCard` en haut du feed
  - [ ] Titre "üì∞ Ton briefing du [date]" + sous-titre "Prochaine livraison : demain 8h"
  - [ ] S√©parateur visuel avant le feed normal

- [ ] **Task 7: Composant `BriefingCard`**
  - [ ] √âtat "non lu" : badge üìå, fond normal
  - [ ] √âtat "lu" : fond att√©nu√©, check ‚úì, message "Merci d'avoir lu !"
  - [ ] Afficher `top3_reason` comme tag secondaire

- [ ] **Task 8: Animation post-lecture**
  - [ ] Apr√®s lecture des 3 : collapse anim√© de la section
  - [ ] Afficher message "‚úÖ Briefing termin√© ! Reviens demain √† 8h üì¨"
  - [ ] Mini-banni√®re sticky optionnelle pour re-expand

- [ ] **Task 9: Int√©gration `FeedScreen`**
  - [ ] Provider `dailyTop3Provider` pour r√©cup√©rer le Top 3 du jour
  - [ ] G√©rer le cache Hive avec TTL 24h
  - [ ] Int√©grer `BriefingSection` avant le `ListView` principal

## Dev Notes

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ScoringEngine (existant)       ‚îÇ ‚Üê Inchang√©
‚îÇ  - CoreLayer, QualityLayer...   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ scored_contents[]
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ImportanceDetector (NOUVEAU)   ‚îÇ
‚îÇ  - parse_une_feeds()            ‚îÇ
‚îÇ  - detect_trending_clusters()   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ importance_flags
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Top3Selector (NOUVEAU)         ‚îÇ
‚îÇ  - apply_constraints()          ‚îÇ
‚îÇ  - apply_boosts()               ‚îÇ
‚îÇ  - select_top3()                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ top3[]
             ‚ñº
        DailyTop3 (DB)
```

### Sources "Une" de r√©f√©rence

| Source | Feed Une | Biais |
|--------|----------|-------|
| Le Monde | `https://www.lemonde.fr/rss/une.xml` | Centre |
| France Info | `https://www.francetvinfo.fr/titres.rss` | Centre |
| AFP | √Ä v√©rifier (souvent restreint) | Factuel |
| France 24 | `https://www.france24.com/fr/rss` | Centre (public) |
| Radio France | `https://www.radiofrance.fr/rss` | Centre-gauche (public) |

### Logique de s√©lection Top 3

```python
def select_top3(scored: list, user_followed_sources: set) -> list:
    # √âtape 1 : Appliquer boosts importance
    for c in scored:
        c.top3_score = c.base_score
        if c.from_une_feed:
            c.top3_score += 30  # Une boost
        if c.is_trending:
            c.top3_score += 40  # Trending boost
    
    # √âtape 2 : Trier par score d√©croissant
    sorted_all = sorted(scored, key=lambda c: c.top3_score, reverse=True)
    
    # √âtape 3 : S√©lection slots #1 et #2 (meilleurs globaux, sources distinctes)
    top2 = []
    used_sources = set()
    for c in sorted_all:
        if c.source_id not in used_sources:
            top2.append(c)
            used_sources.add(c.source_id)
        if len(top2) == 2:
            break
    
    # √âtape 4 : Slot #3 R√âSERV√â aux sources suivies
    remaining = [c for c in sorted_all if c not in top2 and c.source_id not in used_sources]
    from_followed = [c for c in remaining if c.source_id in user_followed_sources]
    
    if from_followed:
        slot3 = from_followed[0]  # Meilleur des sources suivies
    else:
        slot3 = remaining[0] if remaining else None  # Fallback si aucune source suivie
    
    return top2 + [slot3] if slot3 else top2
```

> [!IMPORTANT]
> **R√®gle Quota** : Le slot #3 garantit la pr√©sence d'une source de confiance de l'utilisateur, renfor√ßant la proposition de valeur de Facteur.

### Clustering Jaccard (pseudo-code)

```python
def jaccard(a: set, b: set) -> float:
    return len(a & b) / len(a | b) if a | b else 0

def detect_trending(contents: list[Content]) -> set[UUID]:
    clusters = []
    for c in contents:
        tokens = set(normalize(c.title).split())
        matched = False
        for cluster in clusters:
            if jaccard(tokens, cluster["tokens"]) > 0.4:
                cluster["contents"].append(c)
                matched = True
                break
        if not matched:
            clusters.append({"tokens": tokens, "contents": [c]})
    
    trending = set()
    for cluster in clusters:
        sources = set(c.source_id for c in cluster["contents"])
        if len(sources) >= 3:
            trending.update(c.id for c in cluster["contents"])
    return trending
```

## Testing

- **Unit Tests** : `tests/test_top3_selector.py`, `tests/test_importance_detector.py`
- **Integration** : V√©rifier le job CRON en environnement staging
- **Manual** : Simuler des contenus "trending" et valider le boost

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 19/01/2026 | 1.0 | Initial Draft (brainstorm PM + Designer BMAD) | Antigravity |
| 19/01/2026 | 1.1 | Ajout r√®gle Quota source suivie (slot #3 r√©serv√©) | Antigravity |
