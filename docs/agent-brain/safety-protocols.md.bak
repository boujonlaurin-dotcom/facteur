# Safety Protocols - Danger Zones

**Zones √† risque √©lev√© avec v√©rification obligatoire double.**

---

## üî¥ Worktree Isolation (OBLIGATOIRE)

### Pourquoi

**Probl√®me**: Agents parall√®les qui travaillent sur le m√™me repo ‚Üí conflits Git, perte de travail, √©tat incoh√©rent.

**Solution**: Un agent = un worktree = une branche isol√©e.

### Proc√©dure (Ex√©cuter EN PREMIER)

```bash
# 1. Retour sur main, sync avec remote
cd /Users/laurinboujon/Desktop/Projects/Work\ Projects/Facteur
git checkout main && git pull origin main

# 2. Cr√©er branche d√©di√©e
git checkout -b <agent>-<tache>
# Exemples:
#   - dev-digest-share-button
#   - fix-auth-token-refresh
#   - maintenance-migrate-sqlalchemy

# 3. Cr√©er worktree isol√©
git worktree add ../<agent>-<tache> <agent>-<tache>

# 4. Naviguer dans le worktree
cd ../<agent>-<tache>

# 5. V√©rifier l'isolation
git status  # Doit afficher la branche d√©di√©e
pwd         # Doit √™tre dans le worktree isol√©
```

### R√®gles Critiques

1. **Chemins absolus uniquement**: `read $(pwd)/src/file.py`, jamais de relatif
2. **Isolation totale**: Un agent ne doit JAMAIS modifier le repo principal
3. **Nettoyage post-merge**:
   ```bash
   cd /Users/laurinboujon/Desktop/Projects/Work\ Projects/Facteur
   git worktree remove ../<agent>-<tache>
   git branch -d <agent>-<tache>  # Si merg√©e
   ```

### V√©rification Rapide

```bash
# Liste des worktrees actifs
git worktree list

# Si oubli de cleanup:
git worktree prune
```

---

## üî¥ Auth / Security

### Danger

**Impact**: 403 g√©n√©ralis√© (app inutilisable) OU acc√®s libre non-autoris√© (faille s√©curit√©).

### Zones √† Risque

| Fichier | Risque | V√©rification |
|---------|--------|--------------|
| `packages/api/app/dependencies.py` | JWT validation cass√©e ‚Üí 403 everywhere | Test `curl` route prot√©g√©e |
| `apps/mobile/lib/core/auth/auth_state.dart` | State machine fragile ‚Üí loops infinis | Test 4 states (logged out, unconfirmed, confirmed, expired) |
| `packages/api/app/config.py` | `SUPABASE_JWT_SECRET` mismatch ‚Üí tokens invalides | V√©rifie coh√©rence mobile ‚Üî backend |

### Protocole de V√©rification OBLIGATOIRE

**AVANT modification**:

1. **Lire documentation**:
   - [Retrospective Auth Bugs](../retrospective-auth-bugs.md)
   - [Handoff Auth Debug](../handoff_debug_auth.md)

2. **Comprendre le flux complet**:
   ```
   Mobile Login (Supabase.auth)
     ‚Üí JWT Token stock√© (Hive)
       ‚Üí API calls (Authorization: Bearer <token>)
         ‚Üí dependencies.get_current_user_id() validation
           ‚Üí DB query avec user_id filtr√©
   ```

3. **Test manuel BEFORE**:
   ```bash
   # Route prot√©g√©e (doit retourner 200)
   curl -H "Authorization: Bearer $TOKEN" \
        http://localhost:8080/api/users/me

   # Route prot√©g√©e sans token (doit retourner 401)
   curl http://localhost:8080/api/users/me
   ```

**APR√àS modification**:

4. **Test manuel AFTER** (m√™mes commandes)

5. **Test des 4 √©tats d'auth mobile**:
   - [ ] User logged out ‚Üí Redirect login
   - [ ] User logged in, email unconfirmed ‚Üí Confirmation screen
   - [ ] User logged in, email confirmed ‚Üí Home screen
   - [ ] Token expired ‚Üí Auto-refresh OU redirect login

6. **Cr√©er script de v√©rification**:
   ```bash
   # Exemple: docs/qa/scripts/verify_auth_fix.sh
   #!/bin/bash
   TOKEN=$(get_test_token)

   # Protected route
   status=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $TOKEN" \
            http://localhost:8080/api/users/me)

   if [ "$status" -eq 200 ]; then
     echo "‚úÖ Auth OK"
   else
     echo "‚ùå Auth FAIL (status: $status)"
     exit 1
   fi
   ```

### Gardes-Fous Sp√©cifiques

**Email Confirmation (Stale Token Bug)**:

```python
# ‚ùå DANGER: Ne fais JAMAIS √ßa
def is_email_confirmed(token: str) -> bool:
    payload = decode_jwt(token)
    return payload.get("email_confirmed_at") is not None

# ‚úÖ CORRECT: Toujours v√©rifier c√¥t√© serveur
async def is_email_confirmed(user_id: UUID, db: AsyncSession) -> bool:
    result = await db.execute(
        select(auth.users).where(auth.users.c.id == user_id)
    )
    user = result.scalar_one_or_none()
    return user.email_confirmed_at is not None
```

**Raison**: Le JWT peut contenir `email_confirmed_at=null` si g√©n√©r√© avant confirmation. Toujours faire une query fra√Æche.

---

## üî¥ Router / Core Mobile

### Danger

**Impact**: App inutilisable (White Screen of Death), boucles de redirection infinies, navigation cass√©e.

### Zones √† Risque

| Fichier | Risque | V√©rification |
|---------|--------|--------------|
| `apps/mobile/lib/config/routes.dart` | Redirect loops, guards cass√©s | Test tous les flows |
| `apps/mobile/lib/core/auth/auth_state.dart` | State machine race conditions | Test async state changes |
| `apps/mobile/lib/shared/navigation/` | Navigation helpers cass√©s | Test deep links |

### Protocole de V√©rification OBLIGATOIRE

**AVANT modification**:

1. **Mapper tous les paths actuels**:
   ```dart
   // Liste tous les GoRoute dans routes.dart
   // Note: shell routes, redirects, guards
   ```

2. **Documenter le flow actuel**:
   ```
   Splash ‚Üí authStateProvider listen
     ‚Üí IF logged out ‚Üí Login
     ‚Üí IF unconfirmed ‚Üí Confirmation
     ‚Üí IF confirmed ‚Üí Shell (Digest/Feed/Sources/Settings)
   ```

**APR√àS modification**:

3. **Test exhaustif des flows** (mobile simulator):
   - [ ] First launch (logged out) ‚Üí Login screen
   - [ ] Login success (unconfirmed) ‚Üí Confirmation screen
   - [ ] Confirm email ‚Üí Redirect to Digest
   - [ ] Logout ‚Üí Clear state, redirect Login
   - [ ] Deep link (logged in) ‚Üí Navigate to target
   - [ ] Deep link (logged out) ‚Üí Redirect login, navigate after

4. **Test edge cases**:
   - [ ] Refresh page ‚Üí State preserved
   - [ ] Back button ‚Üí Correct navigation stack
   - [ ] Token expired ‚Üí Auto-refresh OU logout

5. **Cr√©er script de v√©rification** (si possible):
   ```bash
   # Exemple: docs/qa/scripts/verify_routing.sh
   # Note: Flutter widget tests recommand√©s ici
   cd apps/mobile
   flutter test test/features/auth/routing_test.dart
   ```

### Gardes-Fous Sp√©cifiques

**Shell Route Guard**:

```dart
// ‚ùå DANGER: Guard qui ne g√®re pas les async state changes
redirect: (context, state) {
  final isAuthenticated = ref.read(authStateProvider).isAuthenticated;
  if (!isAuthenticated) return '/login';
  return null;
}

// ‚úÖ CORRECT: Gestion des √©tats interm√©diaires
redirect: (context, state) async {
  final authState = await ref.read(authStateProvider.future);

  if (authState.isLoading) return null; // Attendre
  if (!authState.isAuthenticated) return '/login';
  if (!authState.isEmailConfirmed) return '/confirm';

  return null; // OK
}
```

---

## üî¥ Infra / Database

### Danger

**Impact**: Crash d√©ploiement, data loss, corruption de sch√©ma, rollback impossible.

### Zones √† Risque

| Fichier | Risque | V√©rification |
|---------|--------|--------------|
| `packages/api/alembic/versions/*.py` | Migration fail en prod, lock timeout | Test sur copie DB prod |
| `packages/api/app/models/*.py` | Breaking changes sch√©ma | Check CASCADE, FK contraints |
| `packages/api/Dockerfile` | Missing dependencies, build fail | `docker build` local |
| `packages/api/app/config.py` | Env vars manquantes ‚Üí crash startup | Check all `os.getenv()` |

### Protocole de V√©rification OBLIGATOIRE

#### Alembic Migrations

**AVANT cr√©ation**:

1. **Lire documentation**:
   - [Maintenance Railway Migrations](../maintenance/maintenance-railway-migrations-lock-jan25.md)
   - [Architecture - Database](../architecture.md#database)

2. **V√©rifier l'√©tat actuel**:
   ```bash
   cd packages/api && source venv/bin/activate
   alembic current  # Quelle r√©vision?
   alembic history  # Historique complet
   ```

3. **Cr√©er migration**:
   ```bash
   alembic revision --autogenerate -m "description pr√©cise"
   ```

4. **REVIEW manuel de la migration**:
   - [ ] Pas de `DROP TABLE` sans sauvegarder data
   - [ ] `ALTER TABLE` avec `DEFAULT` si NOT NULL ajout√©
   - [ ] Index cr√©√©s si FK ajout√©e
   - [ ] Pas de lock timeout risk (cf. Supabase pooler)

**APR√àS cr√©ation, AVANT deploy**:

5. **Test sur DB locale**:
   ```bash
   alembic upgrade head
   # V√©rifier sch√©ma: psql ou DBeaver
   alembic downgrade -1  # Test rollback
   alembic upgrade head  # Re-apply
   ```

6. **Test sur copie DB prod** (si dispo):
   ```bash
   # Dump prod DB (sans data si volumineuse)
   pg_dump --schema-only prod_db > schema.sql

   # Restore sur DB test
   psql test_db < schema.sql

   # Apply migration
   DATABASE_URL=postgresql://test alembic upgrade head
   ```

7. **Plan de rollback pr√™t**:
   ```bash
   # En cas de fail en prod
   alembic downgrade -1
   # OU si migration destructive, restaurer backup
   ```

8. **Fen√™tre de maintenance** (si destructive):
   - [ ] Notifier users
   - [ ] Downtime planifi√© (ex: 3am)
   - [ ] Rollback plan communiqu√©

**APR√àS deploy**:

9. **V√©rifier logs Railway**:
   ```
   [lifespan] Running pending migrations...
   [lifespan] INFO  [alembic.runtime.migration] Running upgrade abc123 -> def456
   [lifespan] Migrations completed successfully
   ```

10. **Test health check**:
    ```bash
    curl https://facteur-production.up.railway.app/api/health/ready
    ```

### Gardes-Fous Sp√©cifiques

**Supabase PgBouncer Lock Timeout**:

```python
# ‚ùå DANGER: Migration qui lock table trop longtemps
def upgrade():
    op.add_column('contents', sa.Column('embedding', sa.ARRAY(sa.Float)))
    # Sur grosse table ‚Üí timeout lock (PgBouncer transaction mode)

# ‚úÖ CORRECT: Migration avec lock timeout handling
def upgrade():
    # Utiliser autocommit_block pour √©viter transaction lock
    from alembic import op
    from sqlalchemy import text

    connection = op.get_bind()

    # Set lock timeout avant modif
    connection.execute(text("SET lock_timeout = '5s'"))

    try:
        op.add_column('contents', sa.Column('embedding', sa.ARRAY(sa.Float)))
    except Exception as e:
        # G√©rer timeout, retry avec batch
        pass
```

**Breaking Changes Model**:

```python
# ‚ùå DANGER: Supprimer colonne sans migration
class Content(Base):
    # OLD: content_html: Mapped[str]
    # Supprimer directement ‚Üí crash prod

# ‚úÖ CORRECT: Migration en 2 √©tapes
# 1. Rendre nullable (deploy 1)
class Content(Base):
    content_html: Mapped[str | None]  # Nullable

# 2. Supprimer colonne apr√®s v√©rif (deploy 2)
# alembic revision: DROP COLUMN content_html
```

---

## üî¥ Docker / Deployment

### Danger

**Impact**: Build fail, missing dependencies, runtime crash, rollback impossible.

### Zones √† Risque

| Fichier | Risque | V√©rification |
|---------|--------|--------------|
| `packages/api/Dockerfile` | Missing COPY, dependencies | `docker build` local |
| `packages/api/requirements.txt` | Version conflicts, Python 3.13+ | `pip install -r requirements.txt` |
| `packages/api/app/main.py` | Startup crash (lifespan events) | Test local + Railway logs |

### Protocole de V√©rification OBLIGATOIRE

**AVANT modification Dockerfile**:

1. **Build local**:
   ```bash
   cd packages/api
   docker build -t facteur-api:test .
   ```

2. **V√©rifier layers**:
   - [ ] Base image: `python:3.12-slim` (PAS 3.13+)
   - [ ] `COPY requirements.txt` AVANT `RUN pip install`
   - [ ] `COPY app/` copie tous modules n√©cessaires
   - [ ] `COPY scripts/` si scripts r√©f√©renc√©s
   - [ ] User non-root: `appuser`

3. **Test run local**:
   ```bash
   docker run -p 8080:8080 \
     -e DATABASE_URL=$DATABASE_URL \
     -e SUPABASE_URL=$SUPABASE_URL \
     -e SUPABASE_ANON_KEY=$SUPABASE_ANON_KEY \
     -e SUPABASE_JWT_SECRET=$SUPABASE_JWT_SECRET \
     facteur-api:test
   ```

4. **Health check**:
   ```bash
   curl http://localhost:8080/api/health
   ```

**APR√àS deploy Railway**:

5. **V√©rifier logs d√©marrage**:
   ```
   [railway] Building image...
   [railway] Pushing to registry...
   [railway] Starting container...
   [lifespan] Starting application...
   [lifespan] Running pending migrations...
   [lifespan] Migrations completed successfully
   [uvicorn] Application startup complete
   ```

6. **Test health check prod**:
   ```bash
   curl https://facteur-production.up.railway.app/api/health/ready
   ```

### Gardes-Fous Sp√©cifiques

**Missing COPY in Dockerfile**:

```dockerfile
# ‚ùå DANGER: Ajouter import mais oublier COPY
# app/services/new_service.py cr√©√©
# Mais Dockerfile n'a pas COPY app/services/new_service.py
# ‚Üí ImportError en prod

# ‚úÖ CORRECT: COPY complet
COPY app/ /app/app/
COPY scripts/ /app/scripts/
# V√©rifie que tous modules sont copi√©s
```

**Python Version Lock**:

```dockerfile
# ‚ùå DANGER: Python 3.13+ casse pydantic-core
FROM python:3.13-slim

# ‚úÖ CORRECT: Lock sur 3.12
FROM python:3.12-slim
```

---

## üìã Quick Safety Checklist

**Avant TOUTE modification code**:

- [ ] **Worktree isol√© cr√©√©** (`git worktree list` pour v√©rifier)
- [ ] **Zone √† risque identifi√©e** (Auth/Router/DB/Infra?)
- [ ] **Docs de s√©curit√© lues** (cf. sections ci-dessus)
- [ ] **Plan de rollback pr√™t** (`git restore` ou `alembic downgrade`)
- [ ] **Tests manuels BEFORE** (√©tat actuel document√©)

**Apr√®s modification code**:

- [ ] **Tests manuels AFTER** (comparaison BEFORE/AFTER)
- [ ] **Script de v√©rification cr√©√©** (`docs/qa/scripts/verify_*.sh`)
- [ ] **Logs v√©rifi√©s** (si deployment)
- [ ] **Documentation MAJ** (si structure change)
- [ ] **Cleanup worktree** (apr√®s merge)

---

*Derni√®re MAJ: 2026-02-14*
