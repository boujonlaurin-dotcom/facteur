---
phase: 03-polish
plan: 04
type: execute
wave: 2
depends_on: ["03-03"]
files_modified:
  - packages/api/app/routers/digest.py
  - packages/api/app/services/digest_service.py
  - packages/api/app/services/digest_selector.py
  - apps/mobile/lib/features/digest/providers/digest_provider.dart
autonomous: true

must_haves:
  truths:
    - "Digest API response time improved (fewer sequential DB queries)"
    - "DigestSelector uses eager loading for source relationships"
    - "Mobile digest provider caches today's digest to avoid redundant API calls"
    - "Existing tests still pass after optimization"
  artifacts:
    - path: "packages/api/app/services/digest_service.py"
      provides: "Optimized digest retrieval with eager loading"
      contains: "selectinload|joinedload"
    - path: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      provides: "Client-side digest caching"
      contains: "cache|_cachedDigest|_lastFetchDate"
  key_links:
    - from: "packages/api/app/services/digest_service.py"
      to: "packages/api/app/services/digest_selector.py"
      via: "optimized query with eager loading"
      pattern: "selectinload|joinedload"
    - from: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      to: "/api/digest"
      via: "cached fetch avoiding redundant calls"
      pattern: "_cachedDigest|_lastFetch"
---

<objective>
Optimize digest API performance and mobile caching.

Purpose: Reduce digest load time by eliminating sequential DB queries (use eager loading + asyncio.gather) and adding client-side caching. With tests from Plan 03 as safety net, refactoring is safe.
Output: Faster digest API, smarter mobile caching, no regressions.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/api/app/services/digest_service.py
@packages/api/app/services/digest_selector.py
@packages/api/app/routers/digest.py
@apps/mobile/lib/features/digest/providers/digest_provider.dart
@apps/mobile/lib/features/digest/repositories/digest_repository.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize backend digest queries with eager loading</name>
  <files>
    packages/api/app/services/digest_service.py
    packages/api/app/services/digest_selector.py
    packages/api/app/routers/digest.py
  </files>
  <action>
    1. In `digest_service.py` — Optimize `get_or_create_digest()`:
       - Current pattern likely has sequential queries: fetch digest rows, then fetch content for each, then fetch source for each content
       - Replace with eager loading: use `selectinload(DailyDigest.content).selectinload(Content.source)` in the initial query
       - If multiple independent queries exist (e.g., fetch digest + fetch user streak), use `asyncio.gather()` to run them in parallel
       - Import `from sqlalchemy.orm import selectinload` if not already imported

    2. In `digest_selector.py` — Optimize `select_digest_articles()`:
       - When fetching candidate content, eager-load source relationship: `.options(selectinload(Content.source))`
       - This avoids N+1 queries during diversity scoring (currently accessing content.source triggers lazy load per item)
       - If user interests and user sources are fetched separately, gather them in parallel

    3. In `digest.py` router — Add structlog timing:
       - Add timing around the digest retrieval call:
         ```python
         import time
         start = time.monotonic()
         # ... existing digest call ...
         elapsed = time.monotonic() - start
         logger.info("digest_retrieved", elapsed_ms=round(elapsed * 1000, 1))
         ```
       - Replace `import logging` with `import structlog` (fix existing tech debt noted in CLAUDE.md)

    AVOID: Don't change the selection algorithm logic — only optimize query patterns. The tests from Plan 03 will catch regressions.
    WHY: CLAUDE.md identifies "Sequential DB queries in feed generation" as tech debt. Same pattern exists in digest.
  </action>
  <verify>
    - `cd packages/api && python -m pytest tests/test_digest_selector.py tests/test_digest_service.py -v` — all tests still pass
    - `python -c "from app.services.digest_service import DigestService; from app.services.digest_selector import DigestSelector"` — imports work
    - No N+1 lazy loading patterns remain (grep for potential issues)
  </verify>
  <done>
    Digest queries use eager loading (selectinload) and parallel fetching (asyncio.gather). Logger upgraded to structlog. Performance timing logged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-side digest caching in mobile provider</name>
  <files>
    apps/mobile/lib/features/digest/providers/digest_provider.dart
  </files>
  <action>
    1. In `digest_provider.dart`, add in-memory caching:
       - Add private fields: `DigestResponse? _cachedDigest`, `String? _cachedDate`
       - In the fetch method, before API call:
         - Check if `_cachedDigest != null && _cachedDate == todayDateString`
         - If yes, return cached data immediately (skip API call)
         - If no (new day or first load), proceed with API call
       - After successful API response, update cache: `_cachedDigest = response; _cachedDate = todayDateString`
       - On action (read/save/dismiss), update the cached digest locally (optimistic update) in addition to the API call
       - Clear cache when user forces refresh or on error

    2. Add a `forceRefresh()` method that clears cache and re-fetches

    AVOID: Don't use Hive/persistent storage for this — it's a simple in-memory cache for the current session. Digest changes daily so stale data risk is low.
    WHY: Users navigate away from digest and back multiple times. Each navigation currently triggers a full API call. Caching the daily digest eliminates redundant calls.
  </action>
  <verify>
    - `flutter analyze` passes
    - Cache logic: first call fetches from API, subsequent calls return cached data for same date
    - Actions update cache locally (optimistic update)
  </verify>
  <done>
    Mobile digest provider caches today's digest in memory. Navigating away and back doesn't trigger redundant API calls. Force refresh available.
  </done>
</task>

</tasks>

<verification>
- Backend tests pass: `cd packages/api && python -m pytest tests/test_digest_selector.py tests/test_digest_service.py -v`
- Frontend compiles: `flutter analyze`
- No lazy loading N+1 patterns in digest service
- structlog used instead of logging module in digest router
</verification>

<success_criteria>
- Eager loading eliminates N+1 queries in digest retrieval and selection
- asyncio.gather used for independent parallel queries where applicable
- Mobile caches daily digest in memory (eliminates redundant API calls on re-navigation)
- All existing tests pass — no regressions
- Performance timing logged via structlog
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish/03-04-SUMMARY.md`
</output>
