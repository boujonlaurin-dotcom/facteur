---
phase: 03-polish
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - packages/api/app/services/digest_service.py
  - packages/api/app/services/digest_selector.py
  - packages/api/app/routers/digest.py
  - apps/mobile/lib/features/digest/providers/digest_provider.dart
autonomous: true

must_haves:
  truths:
    - "Digest API response time improved (fewer sequential DB queries)"
    - "DigestSelector queries use eager loading for source relationships"
    - "Mobile digest provider caches today's digest to avoid redundant API calls"
    - "Existing tests still pass after optimization"
  artifacts:
    - path: "packages/api/app/services/digest_service.py"
      provides: "Optimized digest retrieval with eager loading"
      contains: "selectinload"
    - path: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      provides: "Client-side digest caching"
      contains: "_cachedDigest|_lastFetchDate"
  key_links:
    - from: "packages/api/app/services/digest_service.py"
      to: "packages/api/app/services/digest_selector.py"
      via: "optimized query with eager loading"
      pattern: "selectinload"
    - from: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      to: "/api/digest"
      via: "cached fetch avoiding redundant calls"
      pattern: "_cachedDigest|_lastFetch"
---

<objective>
Optimize digest API performance and add mobile caching.

Purpose: Reduce digest load time by ensuring eager loading is used consistently (no N+1 queries) and adding client-side in-memory caching. With tests from Plan 04 as safety net, refactoring is safe. Builds on top of the analytics wiring from Plan 03 (same digest_provider.dart file).
Output: Faster digest API, smarter mobile caching, no regressions.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-polish/03-RESEARCH.md
@.planning/phases/03-polish/03-03-SUMMARY.md
@.planning/phases/03-polish/03-04-SUMMARY.md
@packages/api/app/services/digest_service.py
@packages/api/app/services/digest_selector.py
@packages/api/app/routers/digest.py
@apps/mobile/lib/features/digest/providers/digest_provider.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize backend digest queries and add timing logs</name>
  <files>
    packages/api/app/services/digest_service.py
    packages/api/app/services/digest_selector.py
    packages/api/app/routers/digest.py
  </files>
  <action>
    1. In `digest_service.py` — Audit and optimize `get_or_create_digest()`:
       - Ensure all Content queries use `selectinload(Content.source)` to avoid N+1 lazy loading
       - If multiple independent queries exist (e.g., fetch digest rows + fetch user streak separately), wrap them with `asyncio.gather()` to run in parallel
       - Import `asyncio` and `selectinload` if not already present
       - RESEARCH.md confirms selectinload is already used in some places — verify ALL digest retrieval paths use it consistently

    2. In `digest_selector.py` — Optimize `select_digest_articles()`:
       - Ensure candidate content query uses `.options(selectinload(Content.source))`
       - If `_build_digest_context()` makes separate queries for user interests, user sources, and existing digests, gather them in parallel with `asyncio.gather()`
       - Verify no lazy loading occurs during diversity scoring (accessing content.source in the loop)

    3. In `digest.py` router — Add performance timing:
       ```python
       import time
       import structlog
       logger = structlog.get_logger()

       # In the digest retrieval endpoint:
       start = time.monotonic()
       # ... existing digest call ...
       elapsed = time.monotonic() - start
       logger.info("digest_retrieved", elapsed_ms=round(elapsed * 1000, 1), user_id=str(user_id))
       ```
       - Replace any `import logging` / `print()` with `structlog` (fix existing tech debt)

    AVOID: Don't change the selection algorithm logic — only optimize query patterns and add parallelism. The tests from Plan 04 catch regressions.
    AVOID: Don't switch from selectinload to joinedload for collections — RESEARCH.md confirms selectinload is correct for Facteur's use case.
  </action>
  <verify>
    - `cd packages/api && python -m pytest tests/test_digest_selector.py tests/test_digest_service.py -v` — all tests still pass
    - `cd packages/api && python -c "from app.services.digest_service import DigestService; from app.services.digest_selector import DigestSelector; print('OK')"`
    - Grep for remaining lazy loading patterns: no `content.source` access without prior selectinload
  </verify>
  <done>
    Digest queries consistently use eager loading (selectinload). Independent queries run in parallel (asyncio.gather). Performance timing logged via structlog in router.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add client-side digest caching in mobile provider</name>
  <files>
    apps/mobile/lib/features/digest/providers/digest_provider.dart
  </files>
  <action>
    In `digest_provider.dart`, add in-memory caching. This builds on the file after Plan 03 has added analytics wiring.

    1. Add private cache fields:
       ```dart
       DigestResponse? _cachedDigest;
       String? _cachedDate;
       ```

    2. In the fetch/load method, before API call:
       - Check if `_cachedDigest != null && _cachedDate == todayDateString`
       - If yes, return cached data immediately (skip API call)
       - If no (new day or first load), proceed with API call
       - After successful API response: `_cachedDigest = response; _cachedDate = todayDateString;`

    3. On action (read/save/dismiss/pass), update the cached digest locally (optimistic update) in addition to the API call. This means the action completion is reflected immediately in UI without re-fetching.

    4. Add a `forceRefresh()` method that clears cache (`_cachedDigest = null; _cachedDate = null;`) and re-fetches.

    5. Clear cache on error responses (so next navigation retries from API).

    AVOID: Don't use Hive/persistent storage — in-memory cache only. Digest changes daily so stale data risk is minimal.
    WHY: Users navigate away from digest and back multiple times per session. Each navigation currently triggers a full API call.
  </action>
  <verify>
    - `cd apps/mobile && flutter analyze` passes
    - Cache logic: first call fetches from API, subsequent calls for same day return cached data
    - Actions update cache locally (optimistic update)
    - forceRefresh() clears cache and re-fetches
  </verify>
  <done>
    Mobile digest provider caches today's digest in memory. Navigating away and back doesn't trigger redundant API calls. Force refresh available. Actions update cache optimistically.
  </done>
</task>

</tasks>

<verification>
- Backend tests pass: `cd packages/api && python -m pytest tests/test_digest_selector.py tests/test_digest_service.py -v`
- Frontend compiles: `cd apps/mobile && flutter analyze`
- selectinload used consistently in all digest query paths
- structlog used in digest router (no raw print/logging)
- Mobile caching prevents redundant API calls
</verification>

<success_criteria>
- Eager loading eliminates N+1 queries in digest retrieval and selection
- asyncio.gather used for independent parallel queries where applicable
- Mobile caches daily digest in memory (eliminates redundant API calls)
- All existing tests pass — no regressions
- Performance timing logged via structlog
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish/03-05-SUMMARY.md`
</output>
