---
phase: 03-polish
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - apps/mobile/lib/features/digest/screens/digest_screen.dart
  - apps/mobile/lib/features/digest/screens/closure_screen.dart
  - apps/mobile/lib/features/digest/providers/digest_provider.dart
  - packages/api/app/services/analytics_service.py
  - packages/api/app/routers/analytics.py
autonomous: true

must_haves:
  truths:
    - "Reading a digest article fires a content_interaction event with action=read, surface=digest"
    - "Saving a digest article fires a content_interaction event with action=save, surface=digest"
    - "Dismissing a digest article fires a content_interaction event with action=dismiss, surface=digest"
    - "Passing a digest article fires a content_interaction event with action=pass, surface=digest"
    - "Completing the digest fires a digest_session event with action breakdown and closure status"
    - "GET /analytics/digest-metrics returns completion rate, average time, and total closures"
  artifacts:
    - path: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      provides: "Analytics wiring for content interactions in digest flow"
      contains: "trackContentInteraction"
    - path: "apps/mobile/lib/features/digest/screens/closure_screen.dart"
      provides: "Digest session tracking on closure"
      contains: "trackDigestSession"
    - path: "packages/api/app/routers/analytics.py"
      provides: "Digest metrics endpoint"
      contains: "digest-metrics"
  key_links:
    - from: "apps/mobile/lib/features/digest/providers/digest_provider.dart"
      to: "apps/mobile/lib/core/services/analytics_service.dart"
      via: "trackContentInteraction calls in action handlers"
      pattern: "trackContentInteraction.*digest"
    - from: "apps/mobile/lib/features/digest/screens/closure_screen.dart"
      to: "apps/mobile/lib/core/services/analytics_service.dart"
      via: "trackDigestSession call on completion"
      pattern: "trackDigestSession"
    - from: "packages/api/app/routers/analytics.py"
      to: "packages/api/app/services/analytics_service.py"
      via: "digest metrics query endpoint"
      pattern: "digest.metrics|get_digest_metrics"
---

<objective>
Wire unified content_interaction analytics into digest screens and add backend metrics endpoint.

Purpose: Connect the unified analytics schema (from Plan 02) to actual user interactions in the digest flow. Each article action (read, save, dismiss, pass) fires a `content_interaction` event. Digest completion fires a `digest_session` event. Backend gets a metrics endpoint for querying digest engagement data.
Output: Fully instrumented digest flow with analytics, backend metrics endpoint for digest KPIs.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-polish/03-CONTEXT.md
@.planning/phases/03-polish/03-02-SUMMARY.md
@apps/mobile/lib/core/services/analytics_service.dart
@apps/mobile/lib/features/digest/providers/digest_provider.dart
@apps/mobile/lib/features/digest/screens/digest_screen.dart
@apps/mobile/lib/features/digest/screens/closure_screen.dart
@packages/api/app/services/analytics_service.py
@packages/api/app/routers/analytics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire content_interaction events into digest provider and screens</name>
  <files>
    apps/mobile/lib/features/digest/providers/digest_provider.dart
    apps/mobile/lib/features/digest/screens/digest_screen.dart
    apps/mobile/lib/features/digest/screens/closure_screen.dart
  </files>
  <action>
    1. In `digest_provider.dart` — In the method that handles article actions (performAction or equivalent):
       - After the API call succeeds, fire a `content_interaction` event:
         ```dart
         analyticsService.trackContentInteraction(
           action: action.name,  // 'read', 'save', 'dismiss'
           surface: 'digest',
           contentId: contentId,
           sourceId: sourceId,
           topics: article.topics ?? [],
           position: articlePosition,  // 1-5
           timeSpentSeconds: timeSpent,  // calculate from article open to close for 'read'
         );
         ```
       - For 'pass' action: when user advances to next card WITHOUT acting (next button without read/save/dismiss), fire:
         ```dart
         analyticsService.trackContentInteraction(
           action: 'pass',
           surface: 'digest',
           contentId: currentArticleContentId,
           sourceId: currentArticleSourceId,
           topics: currentArticle.topics ?? [],
           position: currentPosition,
           timeSpentSeconds: 0,
         );
         ```
       - The provider needs access to AnalyticsService — get it via `ref.read(analyticsServiceProvider)` or inject via constructor, following existing patterns in the codebase.

    2. In `digest_screen.dart` — Track article views (implicit read start):
       - This is NOT where events fire. Events fire in the provider when action completes. But if the screen manages "current article" state, ensure position data is available to the provider.

    3. In `closure_screen.dart` — After closure data is loaded/calculated:
       ```dart
       ref.read(analyticsServiceProvider).trackDigestSession(
         digestDate: digestDate,
         articlesRead: stats.read,
         articlesSaved: stats.saved,
         articlesDismissed: stats.dismissed,
         articlesPassed: stats.passed,
         totalTimeSeconds: totalSessionTime,
         closureAchieved: true,
         streak: currentStreak,
       );
       ```
       - Fire ONCE on mount/data load (use a flag to prevent duplicate fires)
       - The stats should come from the digest completion data

    AVOID: Don't fire events on every scroll or re-render. Events should fire ONCE per action (read completes, save tapped, dismiss tapped, pass/next tapped, closure achieved).
    AVOID: Don't use separate event types (digest_read, digest_save). Use `content_interaction` with `action` field per CONTEXT.md.
  </action>
  <verify>
    - `cd apps/mobile && flutter analyze` passes with no new errors
    - Each action handler in digest_provider calls trackContentInteraction with surface='digest'
    - Closure screen calls trackDigestSession once on completion
    - No separate digest-specific event types used
  </verify>
  <done>
    Every digest article action (read, save, dismiss, pass) fires a unified `content_interaction` event with surface='digest'. Digest completion fires a `digest_session` event with full stats breakdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add backend digest metrics query helpers and endpoint</name>
  <files>
    packages/api/app/services/analytics_service.py
    packages/api/app/routers/analytics.py
  </files>
  <action>
    1. In `analytics_service.py`, add methods:

       - `get_digest_metrics(user_id: UUID, days: int = 7) -> dict`:
         - Query `analytics_events` for events with `event_type='digest_session'` and matching user_id in the last N days
         - Calculate: completion_rate (sessions where closure_achieved=true / total), avg_closure_time (average total_time_seconds), total_closures (count where closure_achieved=true)
         - Use `text()` SQL for aggregation performance (JSONB field access: `event_data->>'closure_achieved'`, `(event_data->>'total_time_seconds')::int`)
         - Return dict: `{"completion_rate": float, "avg_closure_time_seconds": float, "total_closures": int, "total_sessions": int}`

       - `get_interaction_breakdown(user_id: UUID, surface: str = "digest", days: int = 7) -> dict`:
         - Query `analytics_events` for `event_type='content_interaction'` with matching surface in event_data
         - Count by action type (read, save, dismiss, pass)
         - Return dict: `{"read": int, "save": int, "dismiss": int, "pass": int, "total": int}`

    2. In `analytics.py` router, add endpoint:
       ```python
       @router.get("/digest-metrics")
       async def get_digest_metrics(
           days: int = 7,
           user_id: UUID = Depends(get_current_user_id),
           db: AsyncSession = Depends(get_db),
       ):
           service = AnalyticsService(db)
           metrics = await service.get_digest_metrics(user_id, days)
           breakdown = await service.get_interaction_breakdown(user_id, "digest", days)
           return {
               "period_days": days,
               "digest_sessions": metrics,
               "interaction_breakdown": breakdown,
           }
       ```

    Use `list[]` not `List` (Python 3.12 constraint). Use `str | None` not `Optional[str]`.
    AVOID: Don't create a new router — extend the existing analytics router.
  </action>
  <verify>
    - `cd packages/api && python -c "from app.routers.analytics import router; print([r.path for r in router.routes])"` — shows /events and /digest-metrics
    - `cd packages/api && python -c "from app.services.analytics_service import AnalyticsService; print('OK')"`
    - Endpoint uses `text()` for JSONB aggregation, not ORM filtering
  </verify>
  <done>
    Backend has GET /analytics/digest-metrics endpoint returning session completion rate, average closure time, total closures, and interaction breakdown (read/save/dismiss/pass counts). Protected by auth.
  </done>
</task>

</tasks>

<verification>
- `cd apps/mobile && flutter analyze` — no errors
- Backend imports clean: `python -c "from app.routers.analytics import router; from app.services.analytics_service import AnalyticsService"`
- All digest events use unified `content_interaction` type with `surface='digest'`
- Session-level event uses `digest_session` type
- Metrics endpoint returns structured JSON
</verification>

<success_criteria>
- Digest article actions (read/save/dismiss/pass) fire content_interaction events
- Digest completion fires digest_session event
- Backend /analytics/digest-metrics endpoint returns meaningful metrics
- No fragmented event types (no digest_open, digest_action, digest_closure)
- Events fire exactly once per action (no duplication)
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish/03-03-SUMMARY.md`
</output>
