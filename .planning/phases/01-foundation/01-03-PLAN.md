---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - packages/api/app/routers/digest.py
  - packages/api/app/schemas/digest.py
  - packages/api/app/main.py
  - packages/api/app/services/digest_service.py
autonomous: true

must_haves:
  truths:
    - "GET /api/digest returns today's digest with 5 articles"
    - "POST /api/digest/{id}/action updates article action status"
    - "Completion tracking endpoint triggers streak update"
    - "API integrates with existing Personalization system for 'not_interested'"
  artifacts:
    - path: "packages/api/app/routers/digest.py"
      provides: "Digest API endpoints"
      exports: ["GET /api/digest", "POST /api/digest/{digest_id}/action", "POST /api/digest/{digest_id}/complete"]
    - path: "packages/api/app/schemas/digest.py"
      provides: "Pydantic schemas for digest API"
      exports: ["DigestResponse", "DigestItem", "DigestActionRequest", "DigestCompletionResponse"]
    - path: "packages/api/app/services/digest_service.py"
      provides: "Service layer for digest operations"
      exports: ["DigestService"]
  key_links:
    - from: "POST /api/digest/{id}/action"
      to: "Personalization system"
      via: "not_interested action triggers personalization mute"
      pattern: "personalization_service.add_mute"
    - from: "POST /api/digest/{id}/complete"
      to: "Streak service"
      via: "increment closure streak"
      pattern: "streak_service.update_closure_streak"
---

<objective>
Create API endpoints for digest retrieval and actions.

Purpose: Provide REST API for the digest-first mobile app to fetch daily digest, mark articles as read/saved/not_interested, and track completion for gamification.

Output:
- GET /api/digest endpoint (retrieve or generate today's digest)
- POST /api/digest/{id}/action endpoint (read/save/not_interested)
- POST /api/digest/{id}/complete endpoint (completion tracking)
- Pydantic schemas for request/response validation
- DigestService for business logic
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Prior plans (must be complete before this plan)
# @.planning/phases/01-foundation/01-01-SUMMARY.md — Database migrations
# @.planning/phases/01-foundation/01-02-SUMMARY.md — DigestSelector service

# Existing routers to reference
@packages/api/app/routers/feed.py
@packages/api/app/routers/personalization.py
@packages/api/app/routers/streaks.py

# Existing schemas
@packages/api/app/schemas/content.py

# Existing services
@packages/api/app/services/streak_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for digest API</name>
  <files>packages/api/app/schemas/digest.py</files>
  <action>
Create Pydantic schemas for digest API request/response validation.

Schema File (packages/api/app/schemas/digest.py):

1. DigestItemSchema:
   - content_id: UUID
   - content: ContentResponse (nested, from schemas/content.py)
   - rank: int (1-5)
   - reason: str (why selected)
   - action: str ("unread" | "read" | "saved" | "not_interested")
   - action_timestamp: Optional[datetime] (when action taken)

2. DigestResponse:
   - id: UUID
   - date: date
   - items: List[DigestItemSchema] (5 items)
   - completed: bool
   - completed_at: Optional[datetime]
   - progress: Dict[str, int] (e.g., {"read": 2, "saved": 1, "not_interested": 0, "unread": 2})

3. DigestActionRequest:
   - item_rank: int (1-5, which article)
   - action: str ("read" | "saved" | "not_interested")

4. DigestActionResponse:
   - success: bool
   - digest_id: UUID
   - item_rank: int
   - action: str
   - new_progress: Dict[str, int]

5. DigestCompletionResponse:
   - completed: bool
   - completed_at: datetime
   - closure_streak: int
   - time_to_closure_minutes: int
   - message: str (e.g., "Tu es informé !")

Follow existing schema patterns in app/schemas/content.py:
- Use Pydantic v2 syntax (ConfigDict instead of class Config)
- Import UUID from uuid module
- Use proper Field() descriptions for documentation
  </action>
  <verify>
cd packages/api && python -c "from app.schemas.digest import DigestResponse, DigestActionRequest; print('Import OK')"
python -m py_compile packages/api/app/schemas/digest.py
  </verify>
  <done>
All 5 schemas import without errors, follow Pydantic v2 patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DigestService for business logic</name>
  <files>packages/api/app/services/digest_service.py</files>
  <action>
Create DigestService for digest operations and completion tracking.

Service File (packages/api/app/services/digest_service.py):

1. DigestService class:
   - __init__(self, session: AsyncSession)

2. Key methods:

   get_or_create_digest(user_id: UUID, date: date = None) -> DailyDigest:
   - Get today's digest for user, or generate if missing
   - Use DigestSelector (from Plan 01-02) if generation needed
   - Return DailyDigest model instance

   apply_action(user_id: UUID, digest_id: UUID, item_rank: int, action: str) -> DailyDigest:
   - Validate item_rank (1-5)
   - Update items JSONB array: set action for given rank
   - Set action_timestamp
   - If action == "not_interested":
     - Call Personalization service to mute the content's source/theme
     - Reference personalization.py router pattern
   - Save changes
   - Return updated digest

   complete_digest(user_id: UUID, digest_id: UUID) -> Dict:
   - Check all 5 items have action != "unread"
   - Set digest.completed = True, completed_at = now()
   - Create DigestCompletion record with:
     - user_id, date, completed_at
     - time_to_closure_minutes (diff between generation and completion)
     - source_count_at_completion (count user's followed sources)
   - Update closure streak:
     - Check if last_closure_date was yesterday
     - Increment closure_streak or reset to 1
     - Update longest_closure_streak if record
     - Set last_closure_date to today
   - Return completion data

   get_progress(digest: DailyDigest) -> Dict[str, int]:
   - Count items by action status
   - Return {"read": X, "saved": Y, "not_interested": Z, "unread": W}

3. Integration points:
   - Import DigestSelector from plan 01-02
   - Import DailyDigest, DigestCompletion from plan 01-01 models
   - Import StreakService for streak updates
   - Reference personalization router for "not_interested" handling

Follow existing service patterns (briefing_service.py, streak_service.py).
  </action>
  <verify>
cd packages/api && python -c "from app.services.digest_service import DigestService; print('Import OK')"
python -m py_compile packages/api/app/services/digest_service.py
  </verify>
  <done>
DigestService class imports, has get_or_create_digest, apply_action, complete_digest methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Create digest router with API endpoints</name>
  <files>packages/api/app/routers/digest.py, packages/api/app/main.py</files>
  <action>
Create FastAPI router with digest endpoints.

Router File (packages/api/app/routers/digest.py):

1. Router setup:
   ```python
   from fastapi import APIRouter, Depends, HTTPException
   from sqlalchemy.ext.asyncio import AsyncSession
   from app.database import get_db
   from app.dependencies import get_current_user_id
   
   router = APIRouter(prefix="/digest", tags=["digest"])
   ```

2. Endpoints:

   GET / (response_model=DigestResponse):
   - Get current user ID from token
   - Call DigestService.get_or_create_digest(user_id)
   - Return digest with items, progress, completion status
   - Auto-generate if missing (lazy generation like briefing)

   POST /{digest_id}/action (response_model=DigestActionResponse):
   - Path param: digest_id (UUID)
   - Body: DigestActionRequest (item_rank, action)
   - Validate action in ["read", "saved", "not_interested"]
   - Call DigestService.apply_action()
   - Return success with new progress
   - If "not_interested": trigger personalization mute (background or inline)

   POST /{digest_id}/complete (response_model=DigestCompletionResponse):
   - Path param: digest_id (UUID)
   - Verify all 5 items processed (action != "unread")
   - Call DigestService.complete_digest()
   - Return completion data with streak info
   - Return 400 if not all items processed

3. Error handling:
   - 404 if digest not found
   - 400 for invalid action or item_rank
   - 409 if digest already completed

4. Register in main.py:
   - Import router in packages/api/app/main.py
   - Add to app.include_router(digest_router) with proper prefix
   - Route should be at /api/digest (already prefixed in router)

Follow existing router patterns from feed.py:
- Use Depends(get_db) for session injection
- Use Depends(get_current_user_id) for auth
- Use proper Pydantic response models
- Add docstrings for FastAPI docs generation
  </action>
  <verify>
cd packages/api && python -c "from app.routers.digest import router; print('Router import OK')"
# Check main.py compiles:
python -m py_compile packages/api/app/main.py
# Verify routes registered (manual check in main.py):
grep -n "digest" packages/api/app/main.py
  </verify>
  <done>
Router imports without errors, all 3 endpoints defined, registered in main.py
  </done>
</task>

</tasks>

<verification>
1. GET /api/digest returns digest with 5 items or generates one
2. POST /api/digest/{id}/action updates action status and handles "not_interested"
3. POST /api/digest/{id}/complete tracks completion and updates closure streak
4. All endpoints require authentication (get_current_user_id)
5. Pydantic schemas validate requests/responses
6. Integration with DigestSelector (from 01-02) and database models (from 01-01)
7. No regressions in existing feed API
</verification>

<success_criteria>
- GET /api/digest returns DigestResponse with 5 articles and progress
- POST /api/digest/{id}/action updates article action (read/saved/not_interested)
- "Not interested" integrates with Personalization system
- POST /api/digest/{id}/complete marks digest complete and updates streak
- API response time < 500ms (test with curl)
- All endpoints documented in FastAPI docs (/docs)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
