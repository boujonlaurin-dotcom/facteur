---
phase: 02-frontend
plan: 06
type: execute
gap_closure: true
wave: 1
depends_on: []
files_modified:
  - packages/api/alembic/versions/x8y9z0a1b2c3_add_performance_indexes_for_digest.py
  - packages/api/app/services/digest_service.py
  - packages/api/app/services/digest_selector.py
  - packages/api/app/api/routes/digest.py
autonomous: true

must_haves:
  truths:
    - "GET /api/digest returns in under 5 seconds consistently"
    - "Digest generation no longer hangs or times out"
    - "Emergency fallback works when primary selection is slow"
    - "Database queries are optimized with proper indexes"
    - "Mobile app can load and display the digest screen"
  artifacts:
    - path: "packages/api/alembic/versions/x8y9z0a1b2c3_add_performance_indexes_for_digest.py"
      provides: "Database migration for performance indexes"
      exports: ["upgrade", "downgrade"]
    - path: "packages/api/app/services/digest_service.py"
      provides: "Digest service with timeout protection"
      min_lines: 620
    - path: "packages/api/app/services/digest_selector.py"
      provides: "Digest selector with query limits"
      min_lines: 570
    - path: "packages/api/app/api/routes/digest.py"
      provides: "API endpoint with circuit breaker"
  key_links:
    - from: "digest.py"
      to: "digest_service.get_or_create_digest()"
      via: "async call with timeout"
      pattern: "asyncio.wait_for.*digest"
    - from: "digest_service"
      to: "digest_selector.select_for_user()"
      via: "timeout-wrapped call"
      pattern: "await selector.select_for_user.*timeout"
---

<objective>
Fix the digest generation timeout issue that blocks the frontend digest feature from working in production.

Purpose: The GET /api/digest endpoint currently hangs indefinitely (>30s), causing the mobile app to timeout. This is blocking Phase 2 completion and the entire digest user experience.

Output: Working digest endpoint that returns in <5s with proper fallback mechanisms and optimized database queries.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing code that needs optimization
@packages/api/app/services/digest_service.py
@packages/api/app/services/digest_selector.py

# Performance indexes already designed but not applied
@packages/api/sql/012_digest_performance_indexes.sql
@packages/api/alembic/versions/x8y9z0a1b2c3_add_performance_indexes_for_digest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply digest performance database indexes</name>
  <files>
    packages/api/alembic/versions/x8y9z0a1b2c3_add_performance_indexes_for_digest.py
  </files>
  <action>
    Apply the missing database performance indexes for digest queries. The migration file exists but needs to be run.
    
    **Steps:**
    1. Check if indexes already exist in the database
    2. Run the Alembic migration: `alembic upgrade x8y9z0a1b2c3`
    3. Verify indexes are created by querying pg_indexes
    4. Check migration applied successfully
    
    **Indexes to apply (from migration):**
    - ix_contents_source_published (source_id, published_at DESC) - For candidate queries
    - ix_contents_curated_published (published_at, source_id) WHERE Source.is_curated - For emergency fallback
    - ix_user_content_status_exclusion (user_id, content_id, is_hidden, is_saved, status) - For exclusion queries
    - ix_sources_theme (theme) - For muted theme filtering
    
    **What this fixes:**
    The 30s+ timeout was caused by full table scans on Content table during candidate selection. These indexes will make the queries execute in <100ms.
  </action>
  <verify>
    Run these verification commands:
    1. Check migration status: `alembic current` in packages/api directory
    2. List created indexes: `psql $DATABASE_URL -c "SELECT indexname FROM pg_indexes WHERE indexname LIKE 'ix_%' ORDER BY indexname;"`
    3. Verify the 4 digest performance indexes exist: ix_contents_source_published, ix_contents_curated_published, ix_user_content_status_exclusion, ix_sources_theme
  </verify>
  <done>
    - Database migration x8y9z0a1b2c3 is applied
    - All 4 performance indexes exist in pg_indexes
    - Indexes show as "valid" in the database
  </done>
</task>

<task type="auto">
  <name>Task 2: Add timeout protection to digest generation</name>
  <files>
    packages/api/app/services/digest_service.py
    packages/api/app/services/digest_selector.py
  </files>
  <action>
    Add hard timeouts to prevent the digest generation from hanging indefinitely. The current code has timing logs but no actual timeout enforcement.
    
    **Changes to digest_service.py:**
    1. Wrap the `select_for_user()` call with asyncio.wait_for() with a 8-second timeout
    2. If timeout occurs, immediately fall back to emergency candidates
    3. Add timeout parameter to selector initialization
    4. Log timeout events for monitoring
    
    **Changes to digest_selector.py:**
    1. Add timeout parameter to _get_candidates() method (default 5s)
    2. Limit fallback iterations to maximum 1 attempt (remove the 168h fallback)
    3. Reduce candidate pool size from 200 to 50 to speed up queries
    4. Add early exit if candidates pool reaches min_pool_size
    
    **What this fixes:**
    Even with indexes, if the database is under load, queries can still be slow. The timeout ensures we always return a digest within 10 seconds total, using emergency content if needed.
  </action>
  <verify>
    Code verification:
    1. Read digest_service.py and confirm `asyncio.wait_for()` wraps the selector call
    2. Confirm timeout is set to 8 seconds
    3. Read digest_selector.py and confirm _get_candidates has timeout logic
    4. Verify fallback is limited to 1 iteration
    5. Check that candidate limit is reduced to 50
  </verify>
  <done>
    - digest_service.py has asyncio.wait_for() with 8s timeout wrapping selector call
    - digest_selector.py _get_candidates() has early exit and reduced pool size
    - Timeout handling logs properly when triggered
    - Emergency fallback triggers on any timeout
  </done>
</task>

<task type="auto">
  <name>Task 3: Add circuit breaker to API endpoint</name>
  <files>
    packages/api/app/api/routes/digest.py
  </files>
  <action>
    Add circuit breaker pattern to the GET /api/digest endpoint to prevent cascading failures and ensure fast failure.
    
    **Changes to digest.py router:**
    1. Add global circuit breaker state (closed/open/half-open) with timestamp
    2. Before calling digest_service, check if circuit is open
    3. If circuit is open, immediately return cached digest or 503 with retry-after header
    4. On service failure/timeout, increment failure count
    5. After 3 failures in 60 seconds, open circuit for 30 seconds
    6. In half-open state, allow 1 test request to check if service recovered
    
    **What this fixes:**
    If the database is under heavy load, multiple concurrent digest requests can overwhelm it. The circuit breaker prevents new requests from hitting the database when it's struggling, returning fast errors instead.
  </action>
  <verify>
    Code verification:
    1. Read digest.py router and confirm circuit breaker state variables exist
    2. Verify failure count tracking logic
    3. Check that circuit opens after threshold failures
    4. Confirm 503 response with retry-after header when circuit is open
  </verify>
  <done>
    - Circuit breaker state tracking exists in digest router
    - Circuit opens after 3 failures in 60s window
    - Circuit stays open for 30s before half-open
    - Returns 503 with retry-after: 30 when circuit is open
  </done>
</task>

<task type="auto">
  <name>Task 4: Test digest endpoint performance</name>
  <files>
    packages/api/test_digest_performance.py
  </files>
  <action>
    Create and run a performance test to verify the digest endpoint responds in under 5 seconds.
    
    **Create test script:**
    1. Create `packages/api/test_digest_performance.py` that:
       - Makes 10 sequential requests to GET /api/digest
       - Measures response time for each request
       - Verifies all responses complete in <5s
       - Checks that response contains 5 articles
       - Tests with both cached and fresh digest generation
    
    **Run the test:**
    2. Ensure local API is running or use staging URL
    3. Run the test with proper auth token
    4. Capture timing results
    
    **What this verifies:**
    The complete fix works end-to-end. The digest loads quickly, contains the expected 5 articles, and doesn't timeout.
  </action>
  <verify>
    Test execution:
    1. Create and run test_digest_performance.py
    2. Verify all 10 requests complete in <5s
    3. Confirm response contains valid digest with 5 items
    4. Check logs for no timeout warnings or errors
  </verify>
  <done>
    - Performance test script created and executed
    - All requests complete in under 5 seconds
    - Response contains 5 valid digest items
    - No timeout errors in logs
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Run database index verification query
2. Confirm digest endpoint returns 200 in <5s
3. Verify mobile app can load digest screen without timeout
4. Check Railway logs show successful digest generation
5. Confirm emergency fallback triggers correctly on edge cases
</verification>

<success_criteria>
- GET /api/digest responds in under 5 seconds consistently
- Digest contains 5 valid articles with proper metadata
- No 504 Gateway Timeout errors from Railway
- Mobile app digest screen loads successfully
- Database indexes show as "valid" in pg_indexes
- Circuit breaker protects against overload
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend/02-06-SUMMARY.md`
</output>
