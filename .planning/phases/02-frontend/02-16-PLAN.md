---
phase: 02-frontend
plan: 16
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/api/app/schemas/digest.py
  - packages/api/app/services/digest_service.py
  - packages/api/app/routers/digest.py
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "API response includes recommendation_reason for each digest item"
    - "recommendation_reason contains label, score_total, and breakdown array"
    - "Frontend receives non-null recommendationReason"
    - "Personalization sheet shows scoring breakdown correctly"
  artifacts:
    - path: "packages/api/app/schemas/digest.py"
      provides: "DigestItem schema with recommendation_reason field"
    - path: "packages/api/app/services/digest_service.py"
      provides: "_build_digest_response includes recommendation_reason in response"
---

<objective>
Fix critical bug where API response does not include recommendation_reason field, causing "Information non disponible" in the UI.

Purpose: Backend logging (02-15) confirms breakdown data IS stored in database, but API response shows `recommendationReason: null` for all items. The issue is in API response serialization - the field is not being included in the response.

Output: Working API response with full scoring breakdown data.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
## Evidence

### Frontend Logs (Critical)
```
DigestItem(contentId: 8e09c3be-..., 
  reason: "Sélection de la rédaction",
  recommendationReason: null  <-- ALWAYS NULL
)
```

All items have `recommendationReason: null` even though:
- Digest was generated at `2026-02-06 17:42:05` (after plan 02-11)
- Backend logging (from 02-15) shows breakdown IS being generated and stored
- The `reason` string (legacy field) is present

## Root Cause

The breakdown data exists in the database, but the **API response does not include `recommendation_reason`**.

Probable causes:
1. **Pydantic schema** - `DigestItem` schema may not have `recommendation_reason` field
2. **Response serialization** - `_build_digest_response()` may not be adding `recommendation_reason` to the response
3. **Field naming** - Mismatch between Python snake_case and JSON camelCase

## Investigation Path

### Step 1: Check Pydantic Schema
File: `packages/api/app/schemas/digest.py`
Verify `DigestItem` schema has:
```python
recommendation_reason: Optional[DigestRecommendationReason] = Field(
    default=None,
    description="Detailed scoring breakdown"
)
```

### Step 2: Check Response Building
File: `packages/api/app/services/digest_service.py` (around line 520-545)
Verify `_build_digest_response()` assigns `recommendation_reason` to each item.

### Step 3: Verify API Response Model
File: `packages/api/app/routers/digest.py`
Ensure GET `/api/digest` returns the full schema including nested objects.

## Quick Test

After fix, run:
```bash
curl -H "Authorization: Bearer TOKEN" \
  https://api/api/digest | jq '.items[0].recommendation_reason'
```

Should return JSON object with breakdown, not `null`.
</context>

<tasks>

<task type="auto">
  <name>Verify and fix Pydantic schema for recommendation_reason</name>
  <files>
    packages/api/app/schemas/digest.py
  </files>
  <action>
    1. Read the DigestItem schema in packages/api/app/schemas/digest.py
    
    2. Verify the schema includes:
       ```python
       class DigestItem(BaseModel):
           # ... other fields ...
           recommendation_reason: Optional[DigestRecommendationReason] = Field(
               default=None,
               description="Detailed scoring breakdown (new, full transparency)"
           )
       ```
    
    3. If the field is missing or incorrectly named, fix it:
       - Field name must be exactly `recommendation_reason` (snake_case for Python)
       - Type must be `Optional[DigestRecommendationReason]`
       - Must reference the `DigestRecommendationReason` schema
    
    4. Also verify `DigestRecommendationReason` schema exists:
       ```python
       class DigestRecommendationReason(BaseModel):
           label: str
           score_total: float
           breakdown: List[DigestScoreBreakdown]
       ```
    
    5. And verify `DigestScoreBreakdown` schema:
       ```python
       class DigestScoreBreakdown(BaseModel):
           label: str
           points: float
           is_positive: bool
       ```
    
    6. Check if there's any `Config` or serialization settings that might exclude the field
  </action>
  <verify>
    - DigestItem schema has recommendation_reason field
    - All related schemas (DigestRecommendationReason, DigestScoreBreakdown) exist
    - No serialization config excluding the field
  </verify>
  <done>
    Pydantic schema correctly includes recommendation_reason field
  </done>
</task>

<task type="auto">
  <name>Fix response building to include recommendation_reason</name>
  <files>
    packages/api/app/services/digest_service.py
  </files>
  <action>
    1. Find the `_build_digest_response` method in digest_service.py (around line 474-555)
    
    2. Locate where DigestItem objects are created (around line 529-545)
    
    3. Verify `recommendation_reason` is being passed:
       ```python
       items.append(DigestItem(
           content_id=content_id,
           title=content.title,
           # ... other fields ...
           reason=item_data["reason"],
           recommendation_reason=recommendation_reason,  # <-- MUST BE HERE
           is_read=action_state["is_read"],
           # ...
       ))
       ```
    
    4. Verify `recommendation_reason` variable is being built correctly (around line 519-526):
       ```python
       # Build recommendation_reason if breakdown exists
       recommendation_reason = None
       if breakdown:
           recommendation_reason = DigestRecommendationReason(
               label=self._determine_top_reason(breakdown),
               score_total=sum(b.points for b in breakdown),
               breakdown=breakdown
           )
       ```
    
    5. Check if there's a type mismatch - the `DigestItem` being built might be:
       - The Pydantic schema (from schemas/digest.py) - CORRECT
       - The dataclass (from digest_selector.py) - WRONG
       
       Make sure we're building the Pydantic schema model, not the dataclass!
    
    6. Look for any conversion/serialization that might drop the field
  </action>
  <verify>
    - _build_digest_response assigns recommendation_reason to each item
    - DigestItem Pydantic model (not dataclass) is being used
    - recommendation_reason variable is properly populated
  </verify>
  <done>
    Response building correctly includes recommendation_reason
  </done>
</task>

<task type="auto">
  <name>Verify API endpoint response model</name>
  <files>
    packages/api/app/routers/digest.py
  </files>
  <action>
    1. Open packages/api/app/routers/digest.py
    
    2. Find the GET /api/digest endpoint
    
    3. Verify the response_model:
       ```python
       @router.get("/api/digest", response_model=DigestResponse)
       async def get_digest(...):
       ```
    
    4. Check if there's any response modification that might strip fields:
       - response_model_exclude_none=True (would exclude None values)
       - Any manual JSON conversion
       - Any intermediate processing
    
    5. Verify DigestResponse schema includes items list with proper typing:
       ```python
       class DigestResponse(BaseModel):
           digest_id: str
           user_id: str
           # ... other fields ...
           items: List[DigestItem]
       ```
    
    6. Check if response_model_by_alias is set (could affect field names)
  </action>
  <verify>
    - API endpoint uses correct response_model
    - No response processing that strips recommendation_reason
    - Proper return statement
  </verify>
  <done>
    API endpoint correctly configured to return recommendation_reason
  </done>
</task>

<task type="auto">
  <name>Test API response and verify fix</name>
  <files>
    packages/api/app/schemas/digest.py
  </files>
  <action>
    1. After making fixes, restart the API server
    
    2. Test the API endpoint directly:
       ```bash
       curl -H "Authorization: Bearer YOUR_TOKEN" \
         http://localhost:8000/api/digest | jq '.items[0]'
       ```
    
    3. Verify the response includes:
       ```json
       {
         "content_id": "...",
         "reason": "Sélection de la rédaction",
         "recommendation_reason": {
           "label": "...",
           "score_total": 245.0,
           "breakdown": [
             {"label": "Thème: ...", "points": 70, "is_positive": true},
             ...
           ]
         }
       }
       ```
    
    4. If recommendation_reason is still null, check:
       - Server was restarted with new code
       - The specific item has breakdown data in database
       - Look at server logs for errors
    
    5. Test in Flutter app to confirm UI now shows "Pourquoi cet article?" with breakdown
  </action>
  <verify>
    - API response includes recommendation_reason
    - recommendation_reason contains breakdown data
    - Flutter app displays scoring transparency correctly
  </verify>
  <done>
    API fix verified, scoring breakdown visible in UI
  </done>
</task>

</tasks>

<verification>
- Pydantic schema includes recommendation_reason field
- _build_digest_response assigns recommendation_reason
- API endpoint returns full response with breakdown
- Flutter receives non-null recommendationReason
- Personalization sheet shows "Pourquoi cet article?" with scoring details
</verification>

<success_criteria>
- API response includes recommendation_reason for all items
- recommendation_reason has label, score_total, and breakdown array
- Frontend receives and displays scoring breakdown
- No "Information non disponible" on fresh digests
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend/02-16-SUMMARY.md`

Also update `.planning/phases/02-frontend/HANDOFF-02-16-SCORING-BREAKDOWN-BUG.md` to mark as resolved.
</output>
