---
phase: 02-frontend
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/api/app/schemas/digest.py
  - packages/api/app/services/digest_selector.py
  - packages/api/app/services/digest_service.py
  - packages/api/app/api/routes/digest.py
autonomous: true
must_haves:
  truths:
    - "Backend returns full DigestRecommendationReason with breakdown array"
    - "Each digest item has detailed scoring contributions (Theme, Source, Topics, etc.)"
    - "Old 'reason' string field preserved for backward compatibility"
    - "API captures all scoring layer contributions during selection"
  artifacts:
    - path: "packages/api/app/schemas/digest.py"
      provides: "DigestScoreBreakdown and DigestRecommendationReason schemas"
      contains: "class DigestScoreBreakdown|class DigestRecommendationReason"
    - path: "packages/api/app/services/digest_selector.py"
      provides: "Scoring contribution capture in _score_candidates()"
      contains: "breakdown.*append|DigestScoreBreakdown"
    - path: "packages/api/app/api/routes/digest.py"
      provides: "Enhanced digest response with recommendation_reason"
      contains: "_determine_top_reason|recommendation_reason="
  key_links:
    - from: "digest_selector.py _score_candidates()"
      to: "DigestItem with breakdown"
      via: "Capturing ScoreContribution during scoring"
    - from: "DigestScoreBreakdown schema"
      to: "API response"
      via: "Pydantic serialization in DigestItemResponse"
---

<objective>
Extend digest API to return detailed scoring transparency ("Pourquoi cet article?") matching the feed's RecommendationReason structure.

Purpose: Enable users to understand why each article was selected for their digest, building trust through algorithmic transparency.
Output: Enhanced digest endpoints returning full scoring breakdown with points and labels.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-frontend/02-frontend-UI_REWORK_CONTEXT.md
@.planning/IMPLEMENTATION_PLAN_2026-02-06.md

## Reference: Feed Implementation Pattern

The feed already has full scoring transparency implemented in:
- `packages/api/app/schemas/content.py`: ScoreContribution and RecommendationReason classes
- Frontend: `ScoreContribution` and `RecommendationReason` models in content_model.dart

## Current Digest State

Digest only has simple `reason: str` field (e.g., "Source suivie : TechCrunch"). This plan adds the full breakdown matching feed's pattern.

## Scoring Weights Reference (from scoring_config.py)

```python
THEME_MATCH = 70.0              # CoreLayer
TRUSTED_SOURCE = 40.0           # CoreLayer  
CUSTOM_SOURCE_BONUS = 10.0      # CoreLayer
TOPIC_MATCH = 60.0              # ArticleTopicLayer (max 2)
SUBTOPIC_PRECISION_BONUS = 20.0 # ArticleTopicLayer
CURATED_SOURCE = 10.0           # QualityLayer
FQS_LOW_MALUS = -30.0           # QualityLayer
# Format preference = 15.0      # StaticPreferenceLayer
```

## Recency Bonuses (from Task 1/01-04)

```python
RECENT_VERY_BONUS = 30.0      # < 6 hours
RECENT_BONUS = 25.0           # 6-24 hours
RECENT_DAY_BONUS = 15.0       # 24-48 hours
RECENT_YESTERDAY_BONUS = 8.0  # 48-72 hours
RECENT_WEEK_BONUS = 3.0       # 72-120 hours
RECENT_OLD_BONUS = 1.0        # 120-168 hours
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Pydantic Schemas with Breakdown Models</name>
  <files>packages/api/app/schemas/digest.py</files>
  <action>
    Add two new Pydantic models to digest.py following the exact pattern from content.py's ScoreContribution and RecommendationReason:

    1. **DigestScoreBreakdown** - Individual scoring contribution:
       - label: str (e.g., "Thème matché : Tech")
       - points: float (e.g., 70.0)
       - is_positive: bool (true for bonuses, false for penalties)

    2. **DigestRecommendationReason** - Complete reasoning:
       - label: str (top-level summary, e.g., "Vos intérêts : Tech")
       - score_total: float (sum of all contributions)
       - breakdown: List[DigestScoreBreakdown] (detailed contributions)

    3. **Update DigestItem** - Add new optional field:
       - Keep existing `reason: str` for backward compatibility
       - Add `recommendation_reason: Optional[DigestRecommendationReason] = None`

    Import statements to add:
    ```python
    from typing import List, Optional
    ```

    Follow the exact structure from content.py lines 34-45. Use Python 3.9+ list[...] syntax consistently with existing code.
  </action>
  <verify>
    Run: `cd packages/api && python -c "from app.schemas.digest import DigestScoreBreakdown, DigestRecommendationReason; print('Schemas OK')"`
    Should output: "Schemas OK" with no import errors
  </verify>
  <done>
    DigestScoreBreakdown and DigestRecommendationReason classes exist in digest.py
    DigestItem has both old 'reason' field and new 'recommendation_reason' field
    Schemas import without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Capture Scoring Contributions in DigestSelector</name>
  <files>packages/api/app/services/digest_selector.py</files>
  <action>
    Modify the `_score_candidates()` method to capture each scoring layer's contribution:

    1. **Update method signature** to return tuple of (content, score, breakdown):
       ```python
       def _score_candidates(
           self, 
           candidates: List[Content], 
           context: DigestContext
       ) -> List[tuple[Content, float, List[DigestScoreBreakdown]]]:
       ```

    2. **Capture CoreLayer contributions:**
       - Theme match: +70 pts with label "Thème matché : {theme}"
       - Source followed: +40 pts with label "Source de confiance"
       - Custom source: +10 pts with label "Ta source personnalisée"

    3. **Capture Recency bonus (already implemented in 01-04):**
       - Add to breakdown with appropriate label based on age:
         - "Article très récent (< 6h)": +30 pts
         - "Article récent (< 24h)": +25 pts
         - "Publié aujourd'hui": +15 pts
         - "Publié hier": +8 pts
         - "Article de la semaine": +3 pts
         - "Article ancien": +1 pt

    4. **Capture ArticleTopicLayer contributions:**
       - Topic matches: +60 pts each (max 2) with label "Sous-thème : {topic}"
       - Subtopic precision: +20 pts with label "Précision thématique"

    5. **Capture StaticPreferenceLayer:**
       - Format match: +15 pts with label "Format préféré : {format}"

    6. **Capture QualityLayer contributions:**
       - Curated source: +10 pts with label "Source qualitative"
       - Low reliability (< 0.5): -30 pts with label "Fiabilité source faible" (is_positive=False)

    7. **Return format:**
       ```python
       scored.append((content, score, breakdown))
       ```

    Each contribution must be a DigestScoreBreakdown object appended to the breakdown list.
  </action>
  <verify>
    Run: `cd packages/api && python -c "
    from app.services.digest_selector import DigestSelector
    from app.schemas.digest import DigestScoreBreakdown
    ds = DigestSelector()
    print(f'Method exists: {hasattr(ds, \"_score_candidates\")}')
    print('DigestSelector OK')
    "`
    Should output method exists and "DigestSelector OK"
  </verify>
  <done>
    _score_candidates returns List[tuple[Content, float, List[DigestScoreBreakdown]]]
    All 5 scoring layers capture contributions to breakdown list
    Each DigestScoreBreakdown has label, points, and is_positive fields
  </done>
</task>

<task type="auto">
  <name>Task 3: Update API Response with Enhanced Reasoning</name>
  <files>packages/api/app/api/routes/digest.py, packages/api/app/services/digest_service.py</files>
  <action>
    Update the digest API response construction to include full recommendation reason:

    1. **In digest_service.py** - Update `_build_digest_response()`:
       - When building DigestItem objects, pass the breakdown list from scoring
       - Store breakdown alongside each item

    2. **In digest.py routes** - Add helper function `_determine_top_reason()`:
       ```python
       def _determine_top_reason(breakdown: List[DigestScoreBreakdown]) -> str:
           '''Extract the most significant positive reason for the label.'''
           positive = [b for b in breakdown if b.is_positive]
           if not positive:
               return "Sélectionné pour vous"
           
           # Sort by points descending
           positive.sort(key=lambda x: x.points, reverse=True)
           top = positive[0]
           
           # Format based on top reason type
           if "Thème" in top.label:
               return f"Vos intérêts : {top.label.split(': ')[1]}"
           elif "Source de confiance" in top.label:
               return "Source suivie"
           elif "Source personnalisée" in top.label:
               return "Ta source personnalisée"
           elif "Sous-thème" in top.label:
               topics = [b.label.split(': ')[1] for b in positive 
                        if "Sous-thème" in b.label][:2]
               return f"Vos centres d'intérêt : {', '.join(topics)}"
           else:
               return top.label
       ```

    3. **Update response construction** in GET /api/digest:
       ```python
       digest_items = [
           DigestItemResponse(
               # ... existing fields ...
               reason=item.reason,  # Keep old field for backward compatibility
               recommendation_reason=DigestRecommendationReason(
                   label=_determine_top_reason(item.breakdown),
                   score_total=sum(b.points for b in item.breakdown),
                   breakdown=[
                       DigestScoreBreakdown(
                           label=b.label,
                           points=b.points,
                           is_positive=b.is_positive
                       ) for b in item.breakdown
                   ]
               ) if item.breakdown else None
           )
           for item in digest_items
       ]
       ```

    4. **Update DigestItemResponse** to use the enhanced DigestItem from Task 1
  </action>
  <verify>
    Run: `cd packages/api && python -m pytest tests/ -k "digest" -v --tb=short 2>&1 | head -50`
    All existing digest tests should pass
    No regressions in API behavior
  </verify>
  <done>
    GET /api/digest returns items with recommendation_reason field
    Each recommendation_reason has label, score_total, and breakdown array
    Old 'reason' string field still present for backward compatibility
    All existing tests pass
  </done>
</task>

</tasks>

<verification>
1. Test API endpoint: `curl -H "Authorization: Bearer $TOKEN" /api/digest | jq '.items[0].recommendation_reason'`
   - Should return object with label, score_total, breakdown array
2. Verify backward compatibility: Check that old 'reason' field still exists
3. Verify breakdown structure: Each item should have label (str), points (float), is_positive (bool)
4. Check scoring layers: Verify theme, source, topic, recency, quality contributions are present
</verification>

<success_criteria>
- Backend returns full `DigestRecommendationReason` with breakdown array containing 4-8 items
- Each breakdown item has label (human-readable French), points (numeric), is_positive (boolean)
- Old `reason` string field preserved for backward compatibility
- New `recommendation_reason` field is optional (null if no breakdown)
- API response includes contributions from all scoring layers (Core, Recency, Topics, Preferences, Quality)
- Total score is sum of all contributions
- Top reason label is intelligently derived from highest positive contribution
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend/02-11-SUMMARY.md`
</output>
