---
phase: 02-frontend
plan: 09
type: execute
wave: 1
depends_on: []
files_modified: [packages/api/app/services/digest_service.py]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "_build_digest_response() loads content.source eagerly without triggering lazy loading"
    - "Digest API responds without MissingGreenlet errors"
  artifacts:
    - path: "packages/api/app/services/digest_service.py"
      provides: "Eager loading for content.source in digest response builder"
      imports: ["from sqlalchemy.orm import selectinload"]
      pattern: "select(Content).options(selectinload(Content.source))"
  key_links:
    - from: "_build_digest_response()"
      to: "Content.source relationship"
      via: "selectinload eager loading"
      pattern: "\.options\(selectinload\(Content\.source\)\)"
---

<objective>
Fix MissingGreenlet error by adding eager loading for content.source relationship in digest_service.py.

Purpose: Line 386 uses session.get(Content, content_id) without eager loading, then accesses content.source (line 408), triggering lazy loading in async context which causes MissingGreenlet crash.
Output: Working digest API that loads content and source data in a single query without lazy loading.
</objective>

<execution_context>
@/Users/laurinboujon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/laurinboujon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-frontend/02-frontend-UAT.md
@packages/api/app/services/digest_service.py
</context>

<tasks>

<task type="auto">
  <name>Fix eager loading in _build_digest_response()</name>
  <files>packages/api/app/services/digest_service.py</files>
  <action>
    Fix the _build_digest_response() method (around line 380-425) to use eager loading:

    1. Add import at top of file if not already present:
       from sqlalchemy.orm import selectinload
    
    2. Replace the current query pattern at line 386:
       FROM:
         content = await self.session.get(Content, content_id)
       
       TO:
         stmt = select(Content).options(selectinload(Content.source)).where(Content.id == content_id)
         result = await self.session.execute(stmt)
         content = result.scalar_one_or_none()
    
    3. Keep all existing error handling and warning logging intact.
    
    4. Follow the pattern already established in _get_emergency_candidates() method (lines 158-166) which correctly uses selectinload(Content.source).

    The fix ensures content.source is loaded eagerly when building DigestItem objects, preventing lazy loading triggers in async context.
  </action>
  <verify>
    grep -n "selectinload" packages/api/app/services/digest_service.py | head -5
    grep -n "from sqlalchemy.orm import selectinload" packages/api/app/services/digest_service.py
    grep -n "select(Content).options(selectinload(Content.source))" packages/api/app/services/digest_service.py
  </verify>
  <done>
    - import selectinload added to file
    - _build_digest_response() uses selectinload(Content.source) pattern
    - No more session.get(Content, content_id) in that method
    - Code follows same pattern as _get_emergency_candidates()
  </done>
</task>

</tasks>

<verification>
- [ ] Code review: _build_digest_response() uses selectinload pattern
- [ ] Import check: selectinload imported from sqlalchemy.orm
- [ ] Pattern consistency: Same as _get_emergency_candidates()
</verification>

<success_criteria>
- MissingGreenlet error resolved when accessing digest endpoint
- content.source relationship loaded eagerly without lazy loading
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend/02-09-SUMMARY.md`
</output>
