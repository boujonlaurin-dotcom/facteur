# Story 10.17 : Tests Unitaires DigestSelector

## Status: Draft

## Story

**As a** développeur,  
**I want** des tests unitaires complets pour le DigestSelector,  
**so that** je puisse valider le comportement de l'algorithme de sélection.

## Acceptance Criteria

1. **Couverture** des principaux scénarios
2. **Tests de scoring** pour chaque critère
3. **Tests de contraintes** de diversité
4. **Tests de fallback** sources curées
5. **Tests edge cases** (pool vide, utilisateur sans sources, etc.)

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Setup test fixtures**
  - [ ] Factory pour User, Source, Content
  - [ ] Database de test

- [ ] **Task 2: Tests de scoring**
  - [ ] Test boost thème (+50)
  - [ ] Test boost fraîcheur (+30)
  - [ ] Test boost Une (+40)
  - [ ] Test boost trending (+35)
  - [ ] Test boost/malus qualité

- [ ] **Task 3: Tests de contraintes**
  - [ ] Test max 2/source
  - [ ] Test max 2/thème
  - [ ] Test 5 articles retournés

- [ ] **Task 4: Tests de fallback**
  - [ ] Test activation quand < 5
  - [ ] Test sources curées alignées thèmes
  - [ ] Test digest_reason = "Suggestion qualité"

- [ ] **Task 5: Tests edge cases**
  - [ ] Test pool vide → []
  - [ ] Test user sans sources → fallback total
  - [ ] Test tous contenus consommés → []

## Dev Notes

### Structure des tests

```python
# tests/services/test_digest_selector.py

import pytest
from datetime import datetime, timedelta
from uuid import uuid4

from app.services.digest_selector import DigestSelector
from app.models import User, Source, Content, UserSource, UserInterest


@pytest.fixture
def user():
    return User(id=uuid4())


@pytest.fixture
def sources(user):
    """Crée des sources de test."""
    return [
        Source(id=uuid4(), name="TechCrunch", theme="tech", reliability_score="HIGH"),
        Source(id=uuid4(), name="Le Monde", theme="international", reliability_score="HIGH"),
        Source(id=uuid4(), name="Les Echos", theme="economy", reliability_score="MEDIUM"),
    ]


@pytest.fixture
def contents(sources):
    """Crée des contenus de test."""
    now = datetime.utcnow()
    return [
        Content(
            id=uuid4(), 
            source_id=sources[0].id, 
            source=sources[0],
            title="GPT-5 Released",
            published_at=now - timedelta(hours=2),
            from_une_feed=True,
        ),
        Content(
            id=uuid4(), 
            source_id=sources[0].id, 
            source=sources[0],
            title="OpenAI Raises $10B",
            published_at=now - timedelta(hours=6),
            is_trending=True,
        ),
        # ... plus de contenus
    ]


class TestDigestSelectorScoring:
    """Tests pour le scoring des articles."""
    
    async def test_theme_match_boost(self, session, user, sources, contents):
        """Le thème matché ajoute +50 points."""
        # Setup: user intéressé par tech
        await session.execute(
            insert(UserInterest).values(user_id=user.id, interest_slug="tech")
        )
        
        selector = DigestSelector(session)
        scored = selector._score_candidates(contents[:1], {"tech"})
        
        assert scored[0]["score"] >= 50
        assert scored[0]["flags"]["theme_match"] is True
    
    async def test_freshness_boost(self, session, contents):
        """Article < 12h ajoute +30 points."""
        selector = DigestSelector(session)
        scored = selector._score_candidates(contents[:1], set())
        
        # Le premier contenu est à 2h, donc frais
        assert scored[0]["flags"]["is_fresh"] is True
    
    async def test_une_boost(self, session, contents):
        """Article 'À la Une' ajoute +40 points."""
        selector = DigestSelector(session)
        scored = selector._score_candidates(contents[:1], set())
        
        assert scored[0]["flags"]["from_une"] is True
    
    async def test_trending_boost(self, session, contents):
        """Article trending ajoute +35 points."""
        selector = DigestSelector(session)
        scored = selector._score_candidates(contents[1:2], set())
        
        assert scored[0]["flags"]["is_trending"] is True
    
    async def test_quality_malus(self, session, sources, contents):
        """Source LOW reliability retire -30 points."""
        sources[0].reliability_score = "LOW"
        
        selector = DigestSelector(session)
        scored = selector._score_candidates(contents[:1], set())
        
        # Score devrait être négatif ou faible
        assert scored[0]["score"] < 50


class TestDigestSelectorConstraints:
    """Tests pour les contraintes de diversité."""
    
    async def test_max_two_per_source(self, session, user, sources, contents):
        """Maximum 2 articles par source."""
        # Créer 5 contenus de la même source
        same_source_contents = [
            Content(id=uuid4(), source_id=sources[0].id, source=sources[0], 
                    title=f"Article {i}", published_at=datetime.utcnow())
            for i in range(5)
        ]
        
        selector = DigestSelector(session)
        scored = [{"content": c, "score": 100, "flags": {}} for c in same_source_contents]
        
        result = selector._apply_diversity_constraints(scored)
        
        assert len(result) == 2  # Max 2 de la même source
    
    async def test_max_two_per_theme(self, session, user, sources, contents):
        """Maximum 2 articles par thème."""
        # Toutes les sources sont 'tech'
        for s in sources:
            s.theme = "tech"
        
        selector = DigestSelector(session)
        scored = [{"content": c, "score": 100, "flags": {}} for c in contents]
        
        result = selector._apply_diversity_constraints(scored)
        
        assert len(result) <= 2  # Max 2 du même thème
    
    async def test_returns_five_articles(self, session, user, sources):
        """Retourne exactement 5 articles si disponibles."""
        # Créer 10 contenus variés
        contents = []
        for i, source in enumerate(sources * 4):  # 12 contenus
            contents.append(Content(
                id=uuid4(), 
                source_id=source.id, 
                source=source,
                title=f"Article {i}",
                published_at=datetime.utcnow() - timedelta(hours=i),
            ))
        
        selector = DigestSelector(session)
        result = await selector.select_digest(user.id)
        
        assert len(result) == 5


class TestDigestSelectorFallback:
    """Tests pour le fallback sources curées."""
    
    async def test_fallback_activates_when_less_than_five(self, session, user, sources):
        """Fallback activé quand pool < 5."""
        # User suit une seule source avec 2 contenus
        await session.execute(
            insert(UserSource).values(user_id=user.id, source_id=sources[0].id)
        )
        
        # Créer 2 contenus seulement
        for i in range(2):
            session.add(Content(
                id=uuid4(), source_id=sources[0].id,
                title=f"Article {i}", published_at=datetime.utcnow()
            ))
        
        # Créer des sources curées
        curated_source = Source(id=uuid4(), name="Curated", theme="tech", status="CURATED")
        session.add(curated_source)
        for i in range(5):
            session.add(Content(
                id=uuid4(), source_id=curated_source.id,
                title=f"Curated {i}", published_at=datetime.utcnow()
            ))
        await session.commit()
        
        selector = DigestSelector(session)
        result = await selector.select_digest(user.id)
        
        # Devrait avoir 5 articles (2 suivis + 3 curés)
        assert len(result) == 5
        
        # Les articles curés devraient avoir "Suggestion qualité"
        curated_items = [r for r in result if r.digest_reason == "Suggestion qualité"]
        assert len(curated_items) >= 1


class TestDigestSelectorEdgeCases:
    """Tests pour les cas limites."""
    
    async def test_empty_pool_returns_empty(self, session, user):
        """Pool vide retourne liste vide."""
        selector = DigestSelector(session)
        result = await selector.select_digest(user.id)
        
        assert result == []
    
    async def test_user_without_sources(self, session, user):
        """User sans sources utilise fallback total."""
        # Créer des sources curées avec contenu
        # ...
        
        selector = DigestSelector(session)
        result = await selector.select_digest(user.id)
        
        # Devrait retourner des articles curés
        for item in result:
            assert item.digest_reason == "Suggestion qualité"
    
    async def test_all_content_consumed(self, session, user, sources, contents):
        """Tous contenus consommés → liste vide."""
        # Marquer tous les contenus comme consommés
        for c in contents:
            session.add(UserContentStatus(
                user_id=user.id, 
                content_id=c.id, 
                status="consumed"
            ))
        await session.commit()
        
        selector = DigestSelector(session)
        result = await selector.select_digest(user.id)
        
        assert result == []
```

## Definition of Done

- [ ] Tests de scoring couvrent tous les critères
- [ ] Tests de contraintes passent
- [ ] Tests de fallback passent
- [ ] Tests edge cases passent
- [ ] Couverture > 80%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
