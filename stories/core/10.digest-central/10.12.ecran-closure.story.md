# Story 10.12 : Écran de Closure (Animation + Message)

## Status: Draft

## Story

**As a** utilisateur,  
**I want** voir un écran de félicitations après avoir complété mon digest,  
**so that** je ressente la satisfaction de la closure et sois motivé à revenir.

## Acceptance Criteria

1. **Déclenchement automatique** quand 5/5 articles traités
2. **Animation de célébration** (confettis ou similaire)
3. **Message principal** : "Tu es informé !"
4. **Statistiques** :
   - Temps de complétion
   - Streak actuel
5. **Message de fermeture** : "Reviens demain à 8h"
6. **Actions disponibles** :
   - "Voir mes sauvegardes" (si articles sauvegardés)
   - "Explorer le feed" (discret)
   - "Fermer" (retour au digest complété)
7. **Transition fluide** depuis la barre de progression

## Tasks / Subtasks

### Frontend Mobile

- [ ] **Task 1: Créer le screen `ClosureScreen`**
  - [ ] Fichier `apps/mobile/lib/features/digest/screens/closure_screen.dart`
  - [ ] Full-screen overlay ou nouvelle page

- [ ] **Task 2: Implémenter l'animation de célébration**
  - [ ] Package `confetti_widget` ou animation Lottie
  - [ ] Durée ~2 secondes

- [ ] **Task 3: Designer le contenu**
  - [ ] Icône centrale (check ou trophée)
  - [ ] Message "Tu es informé !"
  - [ ] Stats en dessous
  - [ ] Message de fermeture
  - [ ] Boutons d'action

- [ ] **Task 4: Implémenter la logique de déclenchement**
  - [ ] Écouter `isClosureTriggered` dans le provider
  - [ ] Navigation automatique vers ClosureScreen
  - [ ] Empêcher le retour arrière (ou afficher le digest complété)

- [ ] **Task 5: Animations d'entrée**
  - [ ] Fade-in pour le contenu
  - [ ] Scale-in pour l'icône
  - [ ] Staggered pour les stats

## Dev Notes

### ClosureScreen

```dart
// apps/mobile/lib/features/digest/screens/closure_screen.dart

import 'package:flutter/material.dart';
import 'package:confetti_widget/confetti_widget.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ClosureScreen extends ConsumerStatefulWidget {
  final int timeToCompleteSeconds;
  final int closureStreak;
  final int articlesSaved;

  const ClosureScreen({
    super.key,
    required this.timeToCompleteSeconds,
    required this.closureStreak,
    required this.articlesSaved,
  });

  @override
  ConsumerState<ClosureScreen> createState() => _ClosureScreenState();
}

class _ClosureScreenState extends ConsumerState<ClosureScreen>
    with TickerProviderStateMixin {
  late ConfettiController _confettiController;
  late AnimationController _contentController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    
    // Confetti
    _confettiController = ConfettiController(
      duration: const Duration(seconds: 3),
    );
    _confettiController.play();
    
    // Content animations
    _contentController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    
    _fadeAnimation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(
        parent: _contentController,
        curve: const Interval(0.2, 1.0, curve: Curves.easeOut),
      ),
    );
    
    _scaleAnimation = Tween<double>(begin: 0.5, end: 1).animate(
      CurvedAnimation(
        parent: _contentController,
        curve: const Interval(0, 0.6, curve: Curves.elasticOut),
      ),
    );
    
    // Démarrer après un court délai
    Future.delayed(const Duration(milliseconds: 200), () {
      _contentController.forward();
    });
  }

  @override
  void dispose() {
    _confettiController.dispose();
    _contentController.dispose();
    super.dispose();
  }

  String get formattedTime {
    final minutes = widget.timeToCompleteSeconds ~/ 60;
    final seconds = widget.timeToCompleteSeconds % 60;
    if (minutes > 0) {
      return '$minutes min ${seconds}s';
    }
    return '${seconds}s';
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: Colors.black.withOpacity(0.95),
      body: Stack(
        children: [
          // Confetti
          Align(
            alignment: Alignment.topCenter,
            child: ConfettiWidget(
              confettiController: _confettiController,
              blastDirectionality: BlastDirectionality.explosive,
              particleDrag: 0.05,
              emissionFrequency: 0.05,
              numberOfParticles: 30,
              gravity: 0.1,
              colors: const [
                Colors.green,
                Colors.blue,
                Colors.orange,
                Colors.pink,
                Colors.purple,
              ],
            ),
          ),
          
          // Contenu
          SafeArea(
            child: AnimatedBuilder(
              animation: _contentController,
              builder: (context, child) {
                return Opacity(
                  opacity: _fadeAnimation.value,
                  child: child,
                );
              },
              child: Center(
                child: Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Icône animée
                      ScaleTransition(
                        scale: _scaleAnimation,
                        child: Container(
                          width: 120,
                          height: 120,
                          decoration: BoxDecoration(
                            color: Colors.green.withOpacity(0.2),
                            shape: BoxShape.circle,
                          ),
                          child: const Icon(
                            Icons.check_circle,
                            size: 80,
                            color: Colors.green,
                          ),
                        ),
                      ),
                      
                      const SizedBox(height: 32),
                      
                      // Message principal
                      Text(
                        'Tu es informé !',
                        style: theme.textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      
                      const SizedBox(height: 8),
                      
                      Text(
                        'L\'essentiel du jour en $formattedTime',
                        style: theme.textTheme.bodyLarge?.copyWith(
                          color: Colors.grey[400],
                        ),
                      ),
                      
                      const SizedBox(height: 32),
                      
                      // Stats
                      _buildStats(theme),
                      
                      const SizedBox(height: 48),
                      
                      // Message de fermeture
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 20,
                          vertical: 12,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.grey[900],
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.schedule,
                              color: Colors.orange,
                              size: 20,
                            ),
                            const SizedBox(width: 8),
                            Text(
                              'Reviens demain à 8h',
                              style: theme.textTheme.bodyMedium?.copyWith(
                                color: Colors.grey[300],
                              ),
                            ),
                          ],
                        ),
                      ),
                      
                      const SizedBox(height: 48),
                      
                      // Actions
                      _buildActions(context),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStats(ThemeData theme) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // Streak
        _StatItem(
          icon: Icons.local_fire_department,
          value: '${widget.closureStreak}',
          label: 'jours',
          color: Colors.orange,
        ),
        
        const SizedBox(width: 32),
        
        // Sauvegardés
        if (widget.articlesSaved > 0)
          _StatItem(
            icon: Icons.bookmark,
            value: '${widget.articlesSaved}',
            label: 'sauvegardés',
            color: Colors.blue,
          ),
      ],
    );
  }

  Widget _buildActions(BuildContext context) {
    return Column(
      children: [
        // Bouton sauvegardés (si applicable)
        if (widget.articlesSaved > 0) ...[
          OutlinedButton.icon(
            onPressed: () {
              Navigator.of(context).pop();
              context.go('/saved');
            },
            icon: const Icon(Icons.bookmark),
            label: const Text('Voir mes sauvegardes'),
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.blue,
              side: const BorderSide(color: Colors.blue),
              padding: const EdgeInsets.symmetric(
                horizontal: 24,
                vertical: 12,
              ),
            ),
          ),
          const SizedBox(height: 12),
        ],
        
        // Lien feed (discret)
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
            context.go('/feed');
          },
          child: Text(
            'Explorer le feed',
            style: TextStyle(color: Colors.grey[500]),
          ),
        ),
        
        const SizedBox(height: 8),
        
        // Fermer
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text(
            'Fermer',
            style: TextStyle(color: Colors.white),
          ),
        ),
      ],
    );
  }
}

class _StatItem extends StatelessWidget {
  final IconData icon;
  final String value;
  final String label;
  final Color color;

  const _StatItem({
    required this.icon,
    required this.value,
    required this.label,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Icon(icon, color: color, size: 32),
        const SizedBox(height: 4),
        Text(
          value,
          style: Theme.of(context).textTheme.headlineSmall?.copyWith(
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        Text(
          label,
          style: TextStyle(color: Colors.grey[500], fontSize: 12),
        ),
      ],
    );
  }
}
```

### Déclenchement dans DigestProvider

```dart
// Modification dans digest_provider.dart

class DigestNotifier extends AsyncNotifier<DigestState> {
  // ...

  Future<void> actionItem(String contentId, String action) async {
    // ... (code existant)

    try {
      final response = await _repository.actionItem(contentId, action);
      
      if (response.closureTriggered) {
        // Naviguer vers l'écran de closure
        _navigateToClosure(response);
      }
    } catch (e) {
      // ...
    }
  }

  void _navigateToClosure(ActionResponse response) {
    // Option 1: Via un callback
    ref.read(closureCallbackProvider)?.call(
      response.timeToCompleteSeconds ?? 0,
      response.closureStreak,
      response.articlesSaved,
    );
    
    // Option 2: Via state
    state = AsyncValue.data(DigestState(
      digest: _getUpdatedDigest(response),
      isClosureTriggered: true,
      closureData: ClosureData(
        timeToComplete: response.timeToCompleteSeconds ?? 0,
        streak: response.closureStreak,
        articlesSaved: response.articlesSaved,
      ),
    ));
  }
}
```

### Déclenchement dans DigestScreen

```dart
// Dans digest_screen.dart

@override
Widget build(BuildContext context, WidgetRef ref) {
  final digestAsync = ref.watch(digestProvider);
  
  // Écouter le déclenchement de closure
  ref.listen<AsyncValue<DigestState>>(digestProvider, (previous, next) {
    final closureData = next.value?.closureData;
    if (closureData != null && next.value?.isClosureTriggered == true) {
      _showClosureScreen(context, closureData);
    }
  });

  // ...
}

void _showClosureScreen(BuildContext context, ClosureData data) {
  Navigator.of(context).push(
    PageRouteBuilder(
      opaque: false,
      pageBuilder: (_, __, ___) => ClosureScreen(
        timeToCompleteSeconds: data.timeToComplete,
        closureStreak: data.streak,
        articlesSaved: data.articlesSaved,
      ),
      transitionsBuilder: (_, animation, __, child) {
        return FadeTransition(opacity: animation, child: child);
      },
    ),
  );
}
```

### Dépendances

```yaml
# pubspec.yaml
dependencies:
  confetti_widget: ^0.4.0
```

### Références Architecture

- [Source: 5.4.streak-quotidien.md] — Animation célébration existante

## Testing

- **Widget Tests** : `test/features/digest/closure_screen_test.dart`
  - Test affichage stats
  - Test boutons d'action
  - Test animation jouée

## Definition of Done

- [ ] ClosureScreen créé
- [ ] Animation confettis fonctionnelle
- [ ] Stats affichées correctement
- [ ] Navigation depuis DigestScreen
- [ ] Boutons d'action fonctionnels

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
