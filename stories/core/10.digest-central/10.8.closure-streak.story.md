# Story 10.8 : Extension user_streaks pour Closure Streak

## Status: Draft

## Story

**As a** utilisateur,  
**I want** voir mon streak de jours consécutifs de closure,  
**so that** je sois motivé à revenir chaque jour compléter mon digest.

## Acceptance Criteria

1. **Nouveaux champs** dans `user_streaks` : `closure_streak`, `longest_closure_streak`, `last_closure_date`
2. **Calcul automatique** à chaque closure
3. **Logique de streak** :
   - Si closure aujourd'hui et hier = incrémenter
   - Si closure aujourd'hui mais pas hier = reset à 1
   - Si déjà closure aujourd'hui = ignorer
4. **Mise à jour du record** (`longest_closure_streak`) si dépassé
5. **Endpoint** pour récupérer le streak actuel

## Tasks / Subtasks

### Backend

- [ ] **Task 1: Migration Alembic pour user_streaks**
  - [ ] Ajouter colonnes `closure_streak`, `longest_closure_streak`, `last_closure_date`
  - [ ] Valeurs par défaut (0, 0, NULL)

- [ ] **Task 2: Modifier le modèle UserStreak**
  - [ ] Ajouter les nouveaux champs
  - [ ] Méthode `update_closure_streak(completion_date)`

- [ ] **Task 3: Implémenter la logique de calcul**
  - [ ] Connecter à `DigestService._update_closure_streak()`
  - [ ] Logique jour consécutif vs reset
  - [ ] Mise à jour du record

- [ ] **Task 4: Endpoint streak**
  - [ ] `GET /api/user/streak` retourne les infos de streak

- [ ] **Task 5: Inclure dans la réponse digest**
  - [ ] Ajouter `closure_streak` dans `DigestResponse`

## Dev Notes

### Migration SQL

```sql
-- Add closure streak columns to user_streaks
ALTER TABLE user_streaks 
ADD COLUMN IF NOT EXISTS closure_streak INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS longest_closure_streak INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_closure_date DATE;
```

### Modification du modèle

```python
# Modification dans packages/api/app/models/user.py

from datetime import date, timedelta


class UserStreak(Base):
    __tablename__ = "user_streaks"
    
    # ... (champs existants) ...
    
    # Nouveaux champs closure
    closure_streak = Column(Integer, nullable=False, default=0)
    longest_closure_streak = Column(Integer, nullable=False, default=0)
    last_closure_date = Column(Date, nullable=True)
    
    def update_closure_streak(self, completion_date: date) -> int:
        """
        Met à jour le streak de closure.
        
        Returns:
            Le nouveau streak.
        """
        if self.last_closure_date is None:
            # Premier digest complété
            self.closure_streak = 1
        elif self.last_closure_date == completion_date:
            # Déjà complété aujourd'hui, ignorer
            return self.closure_streak
        elif self.last_closure_date == completion_date - timedelta(days=1):
            # Jour consécutif
            self.closure_streak += 1
        else:
            # Streak cassé (> 1 jour d'écart)
            self.closure_streak = 1
        
        # Mise à jour du record
        if self.closure_streak > self.longest_closure_streak:
            self.longest_closure_streak = self.closure_streak
        
        self.last_closure_date = completion_date
        
        return self.closure_streak
```

### Intégration dans DigestService

```python
# Modification dans packages/api/app/services/digest_service.py

from app.models.user import UserStreak


class DigestService:
    # ... (code existant) ...
    
    async def _update_closure_streak(self, user_id: UUID, completion_date: date) -> int:
        """
        Met à jour le streak de closure de l'utilisateur.
        
        Returns:
            Le nouveau streak.
        """
        # Get or create user streak
        result = await self.session.execute(
            select(UserStreak).where(UserStreak.user_id == user_id)
        )
        streak = result.scalar_one_or_none()
        
        if not streak:
            streak = UserStreak(user_id=user_id)
            self.session.add(streak)
        
        # Update streak
        new_streak = streak.update_closure_streak(completion_date)
        
        logger.info(
            "Closure streak updated",
            user_id=str(user_id),
            new_streak=new_streak,
            longest=streak.longest_closure_streak,
        )
        
        return new_streak
```

### Endpoint Streak

```python
# Ajout dans packages/api/app/routers/user_router.py

from app.schemas.user import StreakResponse


@router.get("/streak", response_model=StreakResponse)
async def get_user_streak(
    user_id: str = Depends(get_current_user),
    session: AsyncSession = Depends(get_session),
):
    """Retourne le streak de l'utilisateur."""
    result = await session.execute(
        select(UserStreak).where(UserStreak.user_id == UUID(user_id))
    )
    streak = result.scalar_one_or_none()
    
    if not streak:
        return StreakResponse(
            closure_streak=0,
            longest_closure_streak=0,
            last_closure_date=None,
            # Legacy fields
            current_streak=0,
            longest_streak=0,
        )
    
    return StreakResponse(
        closure_streak=streak.closure_streak,
        longest_closure_streak=streak.longest_closure_streak,
        last_closure_date=streak.last_closure_date,
        current_streak=streak.current_streak,
        longest_streak=streak.longest_streak,
    )
```

### Schéma Pydantic

```python
# packages/api/app/schemas/user.py

from datetime import date
from typing import Optional
from pydantic import BaseModel


class StreakResponse(BaseModel):
    # Closure streak (nouveau)
    closure_streak: int
    longest_closure_streak: int
    last_closure_date: Optional[date]
    
    # Legacy streak (lecture)
    current_streak: int
    longest_streak: int
```

### Inclure dans DigestResponse

```python
# Modification dans packages/api/app/schemas/digest.py

class DigestResponse(BaseModel):
    # ... (champs existants) ...
    
    # Streak info
    closure_streak: int
    longest_closure_streak: int
```

```python
# Modification dans DigestService.enrich_digest_with_content()

async def enrich_digest_with_content(self, digest: DailyDigest) -> DigestResponse:
    # ... (code existant) ...
    
    # Get streak info
    result = await self.session.execute(
        select(UserStreak).where(UserStreak.user_id == digest.user_id)
    )
    streak = result.scalar_one_or_none()
    
    return DigestResponse(
        # ... (champs existants) ...
        closure_streak=streak.closure_streak if streak else 0,
        longest_closure_streak=streak.longest_closure_streak if streak else 0,
    )
```

### Références Architecture

- [Source: 5.4.streak-quotidien.md] — Logique de streak existante
- [Source: models/user.py] — Modèle UserStreak existant

## Testing

- **Unit Tests** : `tests/models/test_user_streak.py`
  - Test premier digest → streak = 1
  - Test jour consécutif → streak incrémenté
  - Test jour manqué → streak reset à 1
  - Test record mis à jour
  - Test idempotence (même jour)

## Definition of Done

- [ ] Champs ajoutés à user_streaks
- [ ] Calcul automatique à la closure
- [ ] Endpoint streak fonctionnel
- [ ] Streak inclus dans DigestResponse
- [ ] Tests passent

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 31/01/2026 | 1.0 | Création story | BMad Master |
